<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>Plasma Engine: plMemoryUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../pl-logo-64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Plasma Engine
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.htm');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.htm','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d4d/classpl_memory_utils.htm','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d0/d7a/classpl_memory_utils-members.htm">List of all members</a>  </div>
  <div class="headertitle"><div class="title">plMemoryUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class provides functions to work on raw memory.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/d0b/_memory_utils_8h_source.htm">MemoryUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17cdb3a4e62f859786496f1a60a56af9" id="r_a17cdb3a4e62f859786496f1a60a56af9"><td class="memItemLeft" align="right" valign="top"><a id="a17cdb3a4e62f859786496f1a60a56af9" name="a17cdb3a4e62f859786496f1a60a56af9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstructorFunction</b> = void (*)(void* pDestination)</td></tr>
<tr class="separator:a17cdb3a4e62f859786496f1a60a56af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8f5aa1fdacd1760372acd2d6282f31" id="r_a2a8f5aa1fdacd1760372acd2d6282f31"><td class="memItemLeft" align="right" valign="top"><a id="a2a8f5aa1fdacd1760372acd2d6282f31" name="a2a8f5aa1fdacd1760372acd2d6282f31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CopyConstructorFunction</b> = void (*)(void* pDestination, const void* pSource)</td></tr>
<tr class="separator:a2a8f5aa1fdacd1760372acd2d6282f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92a1d423abfd89af325ad90e316167c" id="r_ae92a1d423abfd89af325ad90e316167c"><td class="memItemLeft" align="right" valign="top"><a id="ae92a1d423abfd89af325ad90e316167c" name="ae92a1d423abfd89af325ad90e316167c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DestructorFunction</b> = void (*)(void* pDestination)</td></tr>
<tr class="separator:ae92a1d423abfd89af325ad90e316167c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad009398a3bff1542df67ddf83a26c5ac" id="r_ad009398a3bff1542df67ddf83a26c5ac"><td class="memTemplParams" colspan="2"><a id="ad009398a3bff1542df67ddf83a26c5ac" name="ad009398a3bff1542df67ddf83a26c5ac"></a>
template&lt;plConstructionMode mode, typename T &gt; </td></tr>
<tr class="memitem:ad009398a3bff1542df67ddf83a26c5ac"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Construct</b> (T *pDestination, size_t uiCount)</td></tr>
<tr class="separator:ad009398a3bff1542df67ddf83a26c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b5cf6c570cac5c9fa94b8fbe0d6bf" id="r_a5b1b5cf6c570cac5c9fa94b8fbe0d6bf"><td class="memTemplParams" colspan="2"><a id="a5b1b5cf6c570cac5c9fa94b8fbe0d6bf" name="a5b1b5cf6c570cac5c9fa94b8fbe0d6bf"></a>
template&lt;plConstructionMode mode, typename T &gt; </td></tr>
<tr class="memitem:a5b1b5cf6c570cac5c9fa94b8fbe0d6bf"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE plMemoryUtils::ConstructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeConstructorFunction</b> ()</td></tr>
<tr class="separator:a5b1b5cf6c570cac5c9fa94b8fbe0d6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab6980694d9ba8fdccbe3d408b7767" id="r_ac9ab6980694d9ba8fdccbe3d408b7767"><td class="memTemplParams" colspan="2"><a id="ac9ab6980694d9ba8fdccbe3d408b7767" name="ac9ab6980694d9ba8fdccbe3d408b7767"></a>
template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:ac9ab6980694d9ba8fdccbe3d408b7767"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyConstruct</b> (Destination *pDestination, const Source &amp;copy, size_t uiCount)</td></tr>
<tr class="separator:ac9ab6980694d9ba8fdccbe3d408b7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721d16622c4c4b8ce4c6470a6014d3e7" id="r_a721d16622c4c4b8ce4c6470a6014d3e7"><td class="memTemplParams" colspan="2"><a id="a721d16622c4c4b8ce4c6470a6014d3e7" name="a721d16622c4c4b8ce4c6470a6014d3e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721d16622c4c4b8ce4c6470a6014d3e7"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyConstructArray</b> (T *pDestination, const T *pSource, size_t uiCount)</td></tr>
<tr class="separator:a721d16622c4c4b8ce4c6470a6014d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecce0667d02c5d32e6c220cefd9819f4" id="r_aecce0667d02c5d32e6c220cefd9819f4"><td class="memTemplParams" colspan="2"><a id="aecce0667d02c5d32e6c220cefd9819f4" name="aecce0667d02c5d32e6c220cefd9819f4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecce0667d02c5d32e6c220cefd9819f4"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE plMemoryUtils::CopyConstructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeCopyConstructorFunction</b> ()</td></tr>
<tr class="separator:aecce0667d02c5d32e6c220cefd9819f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15b616ba6af4a622ece3b808ad0b46" id="r_a7a15b616ba6af4a622ece3b808ad0b46"><td class="memTemplParams" colspan="2"><a id="a7a15b616ba6af4a622ece3b808ad0b46" name="a7a15b616ba6af4a622ece3b808ad0b46"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a15b616ba6af4a622ece3b808ad0b46"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveConstruct</b> (T *pDestination, T &amp;&amp;source)</td></tr>
<tr class="separator:a7a15b616ba6af4a622ece3b808ad0b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ef54d6f7e6dc471d5f5cb8fa289ae1" id="r_a46ef54d6f7e6dc471d5f5cb8fa289ae1"><td class="memTemplParams" colspan="2"><a id="a46ef54d6f7e6dc471d5f5cb8fa289ae1" name="a46ef54d6f7e6dc471d5f5cb8fa289ae1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46ef54d6f7e6dc471d5f5cb8fa289ae1"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveConstruct</b> (T *pDestination, T *pSource, size_t uiCount)</td></tr>
<tr class="separator:a46ef54d6f7e6dc471d5f5cb8fa289ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6808604b9e663b5633e01c7b62a9294d" id="r_a6808604b9e663b5633e01c7b62a9294d"><td class="memTemplParams" colspan="2"><a id="a6808604b9e663b5633e01c7b62a9294d" name="a6808604b9e663b5633e01c7b62a9294d"></a>
template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a6808604b9e663b5633e01c7b62a9294d"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyOrMoveConstruct</b> (Destination *pDestination, Source &amp;&amp;source)</td></tr>
<tr class="separator:a6808604b9e663b5633e01c7b62a9294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cc77f9bb172ebbfac737885e8d44b6" id="r_aa2cc77f9bb172ebbfac737885e8d44b6"><td class="memTemplParams" colspan="2"><a id="aa2cc77f9bb172ebbfac737885e8d44b6" name="aa2cc77f9bb172ebbfac737885e8d44b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2cc77f9bb172ebbfac737885e8d44b6"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RelocateConstruct</b> (T *pDestination, T *pSource, size_t uiCount)</td></tr>
<tr class="separator:aa2cc77f9bb172ebbfac737885e8d44b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af98495705a9fdfa247d048ea5f59f2" id="r_a0af98495705a9fdfa247d048ea5f59f2"><td class="memTemplParams" colspan="2"><a id="a0af98495705a9fdfa247d048ea5f59f2" name="a0af98495705a9fdfa247d048ea5f59f2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0af98495705a9fdfa247d048ea5f59f2"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Destruct</b> (T *pDestination, size_t uiCount)</td></tr>
<tr class="separator:a0af98495705a9fdfa247d048ea5f59f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60798f18422ae9cdc3b80cb329903dcc" id="r_a60798f18422ae9cdc3b80cb329903dcc"><td class="memTemplParams" colspan="2"><a id="a60798f18422ae9cdc3b80cb329903dcc" name="a60798f18422ae9cdc3b80cb329903dcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60798f18422ae9cdc3b80cb329903dcc"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE plMemoryUtils::DestructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeDestructorFunction</b> ()</td></tr>
<tr class="separator:a60798f18422ae9cdc3b80cb329903dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075cbd3074bf8610b87ca4dd41c28a56" id="r_a075cbd3074bf8610b87ca4dd41c28a56"><td class="memTemplParams" colspan="2"><a id="a075cbd3074bf8610b87ca4dd41c28a56" name="a075cbd3074bf8610b87ca4dd41c28a56"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a075cbd3074bf8610b87ca4dd41c28a56"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Copy</b> (T *pDestination, const T *pSource, size_t uiCount)</td></tr>
<tr class="separator:a075cbd3074bf8610b87ca4dd41c28a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50de3227d6abef6ec204b95e3329c771" id="r_a50de3227d6abef6ec204b95e3329c771"><td class="memTemplParams" colspan="2"><a id="a50de3227d6abef6ec204b95e3329c771" name="a50de3227d6abef6ec204b95e3329c771"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50de3227d6abef6ec204b95e3329c771"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyOverlapped</b> (T *pDestination, const T *pSource, size_t uiCount)</td></tr>
<tr class="separator:a50de3227d6abef6ec204b95e3329c771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5cdc5860902bac727e7f0458786a6" id="r_ae2a5cdc5860902bac727e7f0458786a6"><td class="memTemplParams" colspan="2"><a id="ae2a5cdc5860902bac727e7f0458786a6" name="ae2a5cdc5860902bac727e7f0458786a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2a5cdc5860902bac727e7f0458786a6"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Relocate</b> (T *pDestination, T *pSource, size_t uiCount)</td></tr>
<tr class="separator:ae2a5cdc5860902bac727e7f0458786a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27bf77ff7f517bcdad3085c2fc5a6fc" id="r_ae27bf77ff7f517bcdad3085c2fc5a6fc"><td class="memTemplParams" colspan="2"><a id="ae27bf77ff7f517bcdad3085c2fc5a6fc" name="ae27bf77ff7f517bcdad3085c2fc5a6fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae27bf77ff7f517bcdad3085c2fc5a6fc"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RelocateOverlapped</b> (T *pDestination, T *pSource, size_t uiCount)</td></tr>
<tr class="separator:ae27bf77ff7f517bcdad3085c2fc5a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0956e835028b56f9069f10e7682404" id="r_ada0956e835028b56f9069f10e7682404"><td class="memTemplParams" colspan="2"><a id="ada0956e835028b56f9069f10e7682404" name="ada0956e835028b56f9069f10e7682404"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada0956e835028b56f9069f10e7682404"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, const T &amp;source, size_t uiCount)</td></tr>
<tr class="separator:ada0956e835028b56f9069f10e7682404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c445ccf59f408f511086ee5ae5d0e2a" id="r_a4c445ccf59f408f511086ee5ae5d0e2a"><td class="memTemplParams" colspan="2"><a id="a4c445ccf59f408f511086ee5ae5d0e2a" name="a4c445ccf59f408f511086ee5ae5d0e2a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c445ccf59f408f511086ee5ae5d0e2a"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, T &amp;&amp;source, size_t uiCount)</td></tr>
<tr class="separator:a4c445ccf59f408f511086ee5ae5d0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60402d42ba48949b967a7701d187b562" id="r_a60402d42ba48949b967a7701d187b562"><td class="memTemplParams" colspan="2"><a id="a60402d42ba48949b967a7701d187b562" name="a60402d42ba48949b967a7701d187b562"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60402d42ba48949b967a7701d187b562"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, const T *pSource, size_t uiSourceCount, size_t uiCount)</td></tr>
<tr class="separator:a60402d42ba48949b967a7701d187b562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa024cdee3465f1ff98324b125570bfab" id="r_aa024cdee3465f1ff98324b125570bfab"><td class="memTemplParams" colspan="2"><a id="aa024cdee3465f1ff98324b125570bfab" name="aa024cdee3465f1ff98324b125570bfab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa024cdee3465f1ff98324b125570bfab"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsEqual</b> (const T *a, const T *b, size_t uiCount)</td></tr>
<tr class="separator:aa024cdee3465f1ff98324b125570bfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d43f3ab351c77163ee346cab4b6673" id="r_aa8d43f3ab351c77163ee346cab4b6673"><td class="memTemplParams" colspan="2"><a id="aa8d43f3ab351c77163ee346cab4b6673" name="aa8d43f3ab351c77163ee346cab4b6673"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8d43f3ab351c77163ee346cab4b6673"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ZeroFill</b> (T *pDestination, size_t uiCount)</td></tr>
<tr class="separator:aa8d43f3ab351c77163ee346cab4b6673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c8fd9ebe44cf792d9f9d1b34d0f73" id="r_a736c8fd9ebe44cf792d9f9d1b34d0f73"><td class="memTemplParams" colspan="2"><a id="a736c8fd9ebe44cf792d9f9d1b34d0f73" name="a736c8fd9ebe44cf792d9f9d1b34d0f73"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a736c8fd9ebe44cf792d9f9d1b34d0f73"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ZeroFillArray</b> (T(&amp;destination)[N])</td></tr>
<tr class="separator:a736c8fd9ebe44cf792d9f9d1b34d0f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be1229e6bb483cee0bb812df964a0f" id="r_ad1be1229e6bb483cee0bb812df964a0f"><td class="memTemplParams" colspan="2"><a id="ad1be1229e6bb483cee0bb812df964a0f" name="ad1be1229e6bb483cee0bb812df964a0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1be1229e6bb483cee0bb812df964a0f"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PatternFill</b> (T *pDestination, plUInt8 uiBytePattern, size_t uiCount)</td></tr>
<tr class="separator:ad1be1229e6bb483cee0bb812df964a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19c7cf7a0b1645617578e92e0182cbb" id="r_aa19c7cf7a0b1645617578e92e0182cbb"><td class="memTemplParams" colspan="2"><a id="aa19c7cf7a0b1645617578e92e0182cbb" name="aa19c7cf7a0b1645617578e92e0182cbb"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa19c7cf7a0b1645617578e92e0182cbb"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PatternFillArray</b> (T(&amp;destination)[N], plUInt8 uiBytePattern)</td></tr>
<tr class="separator:aa19c7cf7a0b1645617578e92e0182cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b984366f423d87de392bce1400672d" id="r_a94b984366f423d87de392bce1400672d"><td class="memTemplParams" colspan="2"><a id="a94b984366f423d87de392bce1400672d" name="a94b984366f423d87de392bce1400672d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94b984366f423d87de392bce1400672d"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE plInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Compare</b> (const T *a, const T *b, size_t uiCount)</td></tr>
<tr class="separator:a94b984366f423d87de392bce1400672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f5ae612624c18a71360c97c503e85" id="r_ac12f5ae612624c18a71360c97c503e85"><td class="memTemplParams" colspan="2"><a id="ac12f5ae612624c18a71360c97c503e85" name="ac12f5ae612624c18a71360c97c503e85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac12f5ae612624c18a71360c97c503e85"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddByteOffset</b> (T *pPtr, std::ptrdiff_t offset)</td></tr>
<tr class="separator:ac12f5ae612624c18a71360c97c503e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30624d4ae2eed5a59035da4c6c398563" id="r_a30624d4ae2eed5a59035da4c6c398563"><td class="memTemplParams" colspan="2"><a id="a30624d4ae2eed5a59035da4c6c398563" name="a30624d4ae2eed5a59035da4c6c398563"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30624d4ae2eed5a59035da4c6c398563"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignBackwards</b> (T *pPtr, size_t uiAlignment)</td></tr>
<tr class="separator:a30624d4ae2eed5a59035da4c6c398563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2432a9ca8898068291bf7b8d8291cba2" id="r_a2432a9ca8898068291bf7b8d8291cba2"><td class="memTemplParams" colspan="2"><a id="a2432a9ca8898068291bf7b8d8291cba2" name="a2432a9ca8898068291bf7b8d8291cba2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2432a9ca8898068291bf7b8d8291cba2"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignForwards</b> (T *pPtr, size_t uiAlignment)</td></tr>
<tr class="separator:a2432a9ca8898068291bf7b8d8291cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac6a4a9a4525bb6518b95bd72476ef8" id="r_a8ac6a4a9a4525bb6518b95bd72476ef8"><td class="memTemplParams" colspan="2"><a id="a8ac6a4a9a4525bb6518b95bd72476ef8" name="a8ac6a4a9a4525bb6518b95bd72476ef8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ac6a4a9a4525bb6518b95bd72476ef8"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignSize</b> (T uiSize, T uiAlignment)</td></tr>
<tr class="separator:a8ac6a4a9a4525bb6518b95bd72476ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfbe3f1f2b31b0acecbef49b32bc1b0" id="r_aedfbe3f1f2b31b0acecbef49b32bc1b0"><td class="memTemplParams" colspan="2"><a id="aedfbe3f1f2b31b0acecbef49b32bc1b0" name="aedfbe3f1f2b31b0acecbef49b32bc1b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedfbe3f1f2b31b0acecbef49b32bc1b0"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsAligned</b> (const T *pPtr, size_t uiAlignment)</td></tr>
<tr class="separator:aedfbe3f1f2b31b0acecbef49b32bc1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0949f3b34314054ac3d26425de1f0e" id="r_a8e0949f3b34314054ac3d26425de1f0e"><td class="memTemplParams" colspan="2"><a id="a8e0949f3b34314054ac3d26425de1f0e" name="a8e0949f3b34314054ac3d26425de1f0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e0949f3b34314054ac3d26425de1f0e"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsSizeAligned</b> (T uiSize, T uiAlignment)</td></tr>
<tr class="separator:a8e0949f3b34314054ac3d26425de1f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a611d82f77f3c825a296d39e2bfa3b1c6" id="r_a611d82f77f3c825a296d39e2bfa3b1c6"><td class="memTemplParams" colspan="2">template&lt;plConstructionMode mode, typename T &gt; </td></tr>
<tr class="memitem:a611d82f77f3c825a296d39e2bfa3b1c6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a611d82f77f3c825a296d39e2bfa3b1c6">Construct</a> (T *pDestination, size_t uiCount=1)</td></tr>
<tr class="memdesc:a611d82f77f3c825a296d39e2bfa3b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em>.  <br /></td></tr>
<tr class="separator:a611d82f77f3c825a296d39e2bfa3b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e45b45155a767cebb1940c4f4d36d" id="r_a319e45b45155a767cebb1940c4f4d36d"><td class="memTemplParams" colspan="2"><a id="a319e45b45155a767cebb1940c4f4d36d" name="a319e45b45155a767cebb1940c4f4d36d"></a>
template&lt;plConstructionMode mode, typename T &gt; </td></tr>
<tr class="memitem:a319e45b45155a767cebb1940c4f4d36d"><td class="memTemplItemLeft" align="right" valign="top">static ConstructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeConstructorFunction</b> ()</td></tr>
<tr class="memdesc:a319e45b45155a767cebb1940c4f4d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function pointer to construct an instance of T. Returns nullptr for trivial types. <br /></td></tr>
<tr class="separator:a319e45b45155a767cebb1940c4f4d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b6ac85720d94f8568760ac12f786e5" id="r_a07b6ac85720d94f8568760ac12f786e5"><td class="memTemplParams" colspan="2"><a id="a07b6ac85720d94f8568760ac12f786e5" name="a07b6ac85720d94f8568760ac12f786e5"></a>
template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a07b6ac85720d94f8568760ac12f786e5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyConstruct</b> (Destination *pDestination, const Source &amp;copy, size_t uiCount=1)</td></tr>
<tr class="memdesc:a07b6ac85720d94f8568760ac12f786e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em>, by creating <em>uiCount</em> copies of <em>copy</em>. <br /></td></tr>
<tr class="separator:a07b6ac85720d94f8568760ac12f786e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9d7301372dec5fdcee4015a4620c8e" id="r_a1f9d7301372dec5fdcee4015a4620c8e"><td class="memTemplParams" colspan="2"><a id="a1f9d7301372dec5fdcee4015a4620c8e" name="a1f9d7301372dec5fdcee4015a4620c8e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f9d7301372dec5fdcee4015a4620c8e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyConstructArray</b> (T *pDestination, const T *pSource, size_t uiCount)</td></tr>
<tr class="memdesc:a1f9d7301372dec5fdcee4015a4620c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em> from an existing array of objects at <em>pSource</em> by using copy construction. <br /></td></tr>
<tr class="separator:a1f9d7301372dec5fdcee4015a4620c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483a589dbd88e043d4323e586c90bd7a" id="r_a483a589dbd88e043d4323e586c90bd7a"><td class="memTemplParams" colspan="2"><a id="a483a589dbd88e043d4323e586c90bd7a" name="a483a589dbd88e043d4323e586c90bd7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a483a589dbd88e043d4323e586c90bd7a"><td class="memTemplItemLeft" align="right" valign="top">static CopyConstructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeCopyConstructorFunction</b> ()</td></tr>
<tr class="memdesc:a483a589dbd88e043d4323e586c90bd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function pointer to copy construct an instance of T. <br /></td></tr>
<tr class="separator:a483a589dbd88e043d4323e586c90bd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec7a10f06a461b6d32c183b6347cc80" id="r_abec7a10f06a461b6d32c183b6347cc80"><td class="memTemplParams" colspan="2"><a id="abec7a10f06a461b6d32c183b6347cc80" name="abec7a10f06a461b6d32c183b6347cc80"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abec7a10f06a461b6d32c183b6347cc80"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveConstruct</b> (T *pDestination, T &amp;&amp;source)</td></tr>
<tr class="memdesc:abec7a10f06a461b6d32c183b6347cc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T in a raw buffer at <em>pDestination</em>, by using move construction from <em>source</em>. <br /></td></tr>
<tr class="separator:abec7a10f06a461b6d32c183b6347cc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8145ebb009d76cb343e96465864d51d7" id="r_a8145ebb009d76cb343e96465864d51d7"><td class="memTemplParams" colspan="2"><a id="a8145ebb009d76cb343e96465864d51d7" name="a8145ebb009d76cb343e96465864d51d7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8145ebb009d76cb343e96465864d51d7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveConstruct</b> (T *pDestination, T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:a8145ebb009d76cb343e96465864d51d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em> from an existing array of objects at <em>pSource</em> by using move construction. <br /></td></tr>
<tr class="separator:a8145ebb009d76cb343e96465864d51d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32843c9343c7195dcc1d3ed8122c55e0" id="r_a32843c9343c7195dcc1d3ed8122c55e0"><td class="memTemplParams" colspan="2"><a id="a32843c9343c7195dcc1d3ed8122c55e0" name="a32843c9343c7195dcc1d3ed8122c55e0"></a>
template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a32843c9343c7195dcc1d3ed8122c55e0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyOrMoveConstruct</b> (Destination *pDestination, Source &amp;&amp;source)</td></tr>
<tr class="memdesc:a32843c9343c7195dcc1d3ed8122c55e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will either move call MoveConstruct or CopyConstruct for a single element <em>source</em>, depending on whether it was called with a rvalue reference or a const reference to <em>source</em>. <br /></td></tr>
<tr class="separator:a32843c9343c7195dcc1d3ed8122c55e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a199ddfb8a76151f443013bf3eb8310" id="r_a5a199ddfb8a76151f443013bf3eb8310"><td class="memTemplParams" colspan="2"><a id="a5a199ddfb8a76151f443013bf3eb8310" name="a5a199ddfb8a76151f443013bf3eb8310"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a199ddfb8a76151f443013bf3eb8310"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RelocateConstruct</b> (T *pDestination, T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:a5a199ddfb8a76151f443013bf3eb8310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em> from an existing array of objects at <em>pSource</em> by using move construction if availble, otherwise by copy construction. Calls destructor of source elements in any case (if it is a non primitive or mem-relocatable type). <br /></td></tr>
<tr class="separator:a5a199ddfb8a76151f443013bf3eb8310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe524b6781f69e2fd4eceb18f2a27640" id="r_afe524b6781f69e2fd4eceb18f2a27640"><td class="memTemplParams" colspan="2"><a id="afe524b6781f69e2fd4eceb18f2a27640" name="afe524b6781f69e2fd4eceb18f2a27640"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe524b6781f69e2fd4eceb18f2a27640"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Destruct</b> (T *pDestination, size_t uiCount=1)</td></tr>
<tr class="memdesc:afe524b6781f69e2fd4eceb18f2a27640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs <em>uiCount</em> objects of type T at <em>pDestination</em>. <br /></td></tr>
<tr class="separator:afe524b6781f69e2fd4eceb18f2a27640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5ae39199aab53f5ce3e03e44741b20" id="r_a6e5ae39199aab53f5ce3e03e44741b20"><td class="memTemplParams" colspan="2"><a id="a6e5ae39199aab53f5ce3e03e44741b20" name="a6e5ae39199aab53f5ce3e03e44741b20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e5ae39199aab53f5ce3e03e44741b20"><td class="memTemplItemLeft" align="right" valign="top">static DestructorFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeDestructorFunction</b> ()</td></tr>
<tr class="memdesc:a6e5ae39199aab53f5ce3e03e44741b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function pointer to destruct an instance of T. Returns nullptr for POD-types. <br /></td></tr>
<tr class="separator:a6e5ae39199aab53f5ce3e03e44741b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74df0cde5a8c8012d7b6c48d3d8729" id="r_a9a74df0cde5a8c8012d7b6c48d3d8729"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a74df0cde5a8c8012d7b6c48d3d8729"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a74df0cde5a8c8012d7b6c48d3d8729">Copy</a> (T *pDestination, const T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:a9a74df0cde5a8c8012d7b6c48d3d8729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies objects of type T from <em>pSource</em> to <em>pDestination</em>.  <br /></td></tr>
<tr class="separator:a9a74df0cde5a8c8012d7b6c48d3d8729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88366ff491026f5ddfce3275ce55b4d2" id="r_a88366ff491026f5ddfce3275ce55b4d2"><td class="memItemLeft" align="right" valign="top"><a id="a88366ff491026f5ddfce3275ce55b4d2" name="a88366ff491026f5ddfce3275ce55b4d2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>RawByteCopy</b> (void *pDestination, const void *pSource, size_t uiNumBytesToCopy)</td></tr>
<tr class="memdesc:a88366ff491026f5ddfce3275ce55b4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly <em>uiNumBytesToCopy</em> from <em>pSource</em> to <em>pDestination</em>, independent of the involved types and their sizes. <br /></td></tr>
<tr class="separator:a88366ff491026f5ddfce3275ce55b4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95431ce4b94b94c62927ef693d82b18" id="r_ad95431ce4b94b94c62927ef693d82b18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad95431ce4b94b94c62927ef693d82b18"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad95431ce4b94b94c62927ef693d82b18">CopyOverlapped</a> (T *pDestination, const T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:ad95431ce4b94b94c62927ef693d82b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies objects of type T from <em>pSource</em> to <em>pDestination</em>.  <br /></td></tr>
<tr class="separator:ad95431ce4b94b94c62927ef693d82b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb364a54fec529647934e8f394dff3d" id="r_afbb364a54fec529647934e8f394dff3d"><td class="memTemplParams" colspan="2"><a id="afbb364a54fec529647934e8f394dff3d" name="afbb364a54fec529647934e8f394dff3d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbb364a54fec529647934e8f394dff3d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Relocate</b> (T *pDestination, T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:afbb364a54fec529647934e8f394dff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves objects of type T from <em>pSource</em> to <em>pDestination</em>. <br /></td></tr>
<tr class="separator:afbb364a54fec529647934e8f394dff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad644c6cd5636810d5218474fa2b478c5" id="r_ad644c6cd5636810d5218474fa2b478c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad644c6cd5636810d5218474fa2b478c5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad644c6cd5636810d5218474fa2b478c5">RelocateOverlapped</a> (T *pDestination, T *pSource, size_t uiCount=1)</td></tr>
<tr class="memdesc:ad644c6cd5636810d5218474fa2b478c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves objects of type T from <em>pSource</em> to <em>pDestination</em>.  <br /></td></tr>
<tr class="separator:ad644c6cd5636810d5218474fa2b478c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896238870c5f0caca5ab1464920698b6" id="r_a896238870c5f0caca5ab1464920698b6"><td class="memTemplParams" colspan="2"><a id="a896238870c5f0caca5ab1464920698b6" name="a896238870c5f0caca5ab1464920698b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a896238870c5f0caca5ab1464920698b6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, const T &amp;source, size_t uiCount)</td></tr>
<tr class="memdesc:a896238870c5f0caca5ab1464920698b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves <em>uiCount</em> objects in <em>pDestination</em> by one object and copies <em>source</em> to the free space. <br /></td></tr>
<tr class="separator:a896238870c5f0caca5ab1464920698b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7e75b441e7703845c191ab15993ae0" id="r_a2b7e75b441e7703845c191ab15993ae0"><td class="memTemplParams" colspan="2"><a id="a2b7e75b441e7703845c191ab15993ae0" name="a2b7e75b441e7703845c191ab15993ae0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b7e75b441e7703845c191ab15993ae0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, T &amp;&amp;source, size_t uiCount)</td></tr>
<tr class="memdesc:a2b7e75b441e7703845c191ab15993ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves <em>uiCount</em> objects in <em>pDestination</em> by one object and moves <em>source</em> to the free space. <br /></td></tr>
<tr class="separator:a2b7e75b441e7703845c191ab15993ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6adc3d41e0b96afab52c43705196161" id="r_ae6adc3d41e0b96afab52c43705196161"><td class="memTemplParams" colspan="2"><a id="ae6adc3d41e0b96afab52c43705196161" name="ae6adc3d41e0b96afab52c43705196161"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6adc3d41e0b96afab52c43705196161"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Prepend</b> (T *pDestination, const T *pSource, size_t uiSourceCount, size_t uiCount)</td></tr>
<tr class="memdesc:ae6adc3d41e0b96afab52c43705196161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves <em>uiCount</em> objects in <em>pDestination</em> by <em>uiSourceCount</em> objects and copies <em>source</em> to the free space. <br /></td></tr>
<tr class="separator:ae6adc3d41e0b96afab52c43705196161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4164db412280d367dd4aa34e7c4787e8" id="r_a4164db412280d367dd4aa34e7c4787e8"><td class="memTemplParams" colspan="2"><a id="a4164db412280d367dd4aa34e7c4787e8" name="a4164db412280d367dd4aa34e7c4787e8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4164db412280d367dd4aa34e7c4787e8"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsEqual</b> (const T *a, const T *b, size_t uiCount=1)</td></tr>
<tr class="memdesc:a4164db412280d367dd4aa34e7c4787e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if objects of type T from <em>pSource</em> and <em>pDestination</em> are equal. <br /></td></tr>
<tr class="separator:a4164db412280d367dd4aa34e7c4787e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb44ed929d54c464ebc79e29c0e6f62e" id="r_aeb44ed929d54c464ebc79e29c0e6f62e"><td class="memTemplParams" colspan="2"><a id="aeb44ed929d54c464ebc79e29c0e6f62e" name="aeb44ed929d54c464ebc79e29c0e6f62e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb44ed929d54c464ebc79e29c0e6f62e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ZeroFill</b> (T *pDestination, size_t uiCount=1)</td></tr>
<tr class="memdesc:aeb44ed929d54c464ebc79e29c0e6f62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros every byte in the provided memory buffer. <br /></td></tr>
<tr class="separator:aeb44ed929d54c464ebc79e29c0e6f62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e7847069d21587dc9253d0538d90fe" id="r_a00e7847069d21587dc9253d0538d90fe"><td class="memTemplParams" colspan="2"><a id="a00e7847069d21587dc9253d0538d90fe" name="a00e7847069d21587dc9253d0538d90fe"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a00e7847069d21587dc9253d0538d90fe"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ZeroFill</b> (T(&amp;destination)[N])=delete</td></tr>
<tr class="memdesc:a00e7847069d21587dc9253d0538d90fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to prevent confusing calling this on a single object or a static array of objects. Use <a class="el" href="#a4a991243519b9d2b461604d644aa97b9" title="Zeros every byte in the provided memory buffer.">ZeroFillArray()</a> instead. <br /></td></tr>
<tr class="separator:a00e7847069d21587dc9253d0538d90fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a991243519b9d2b461604d644aa97b9" id="r_a4a991243519b9d2b461604d644aa97b9"><td class="memTemplParams" colspan="2"><a id="a4a991243519b9d2b461604d644aa97b9" name="a4a991243519b9d2b461604d644aa97b9"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4a991243519b9d2b461604d644aa97b9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ZeroFillArray</b> (T(&amp;destination)[N])</td></tr>
<tr class="memdesc:a4a991243519b9d2b461604d644aa97b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros every byte in the provided memory buffer. <br /></td></tr>
<tr class="separator:a4a991243519b9d2b461604d644aa97b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c3feccfb317b5e738f946202ca58f" id="r_a893c3feccfb317b5e738f946202ca58f"><td class="memTemplParams" colspan="2"><a id="a893c3feccfb317b5e738f946202ca58f" name="a893c3feccfb317b5e738f946202ca58f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a893c3feccfb317b5e738f946202ca58f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PatternFill</b> (T *pDestination, plUInt8 uiBytePattern, size_t uiCount=1)</td></tr>
<tr class="memdesc:a893c3feccfb317b5e738f946202ca58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills every byte of the provided buffer with the given value. <br /></td></tr>
<tr class="separator:a893c3feccfb317b5e738f946202ca58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a4ea94b07365189c41478bcaab4c1" id="r_aa50a4ea94b07365189c41478bcaab4c1"><td class="memTemplParams" colspan="2"><a id="aa50a4ea94b07365189c41478bcaab4c1" name="aa50a4ea94b07365189c41478bcaab4c1"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa50a4ea94b07365189c41478bcaab4c1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PatternFill</b> (T(&amp;destination)[N], plUInt8 uiBytePattern)=delete</td></tr>
<tr class="memdesc:aa50a4ea94b07365189c41478bcaab4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to prevent confusing calling this on a single object or a static array of objects. Use <a class="el" href="#ab1d308ced5c5e37116dbe8ab947b2bd3" title="Fills every byte of the provided buffer with the given value.">PatternFillArray()</a> instead. <br /></td></tr>
<tr class="separator:aa50a4ea94b07365189c41478bcaab4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d308ced5c5e37116dbe8ab947b2bd3" id="r_ab1d308ced5c5e37116dbe8ab947b2bd3"><td class="memTemplParams" colspan="2"><a id="ab1d308ced5c5e37116dbe8ab947b2bd3" name="ab1d308ced5c5e37116dbe8ab947b2bd3"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab1d308ced5c5e37116dbe8ab947b2bd3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PatternFillArray</b> (T(&amp;destination)[N], plUInt8 uiBytePattern)</td></tr>
<tr class="memdesc:ab1d308ced5c5e37116dbe8ab947b2bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills every byte of the provided buffer with the given value. <br /></td></tr>
<tr class="separator:ab1d308ced5c5e37116dbe8ab947b2bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab682b66169751ce37b98cd4f9a30e1" id="r_acab682b66169751ce37b98cd4f9a30e1"><td class="memTemplParams" colspan="2"><a id="acab682b66169751ce37b98cd4f9a30e1" name="acab682b66169751ce37b98cd4f9a30e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acab682b66169751ce37b98cd4f9a30e1"><td class="memTemplItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Compare</b> (const T *a, const T *b, size_t uiCount=1)</td></tr>
<tr class="memdesc:acab682b66169751ce37b98cd4f9a30e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two buffers of raw memory byte wise. <br /></td></tr>
<tr class="separator:acab682b66169751ce37b98cd4f9a30e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4fb163aeaf9c445783e5f19bb4f19e" id="r_a8d4fb163aeaf9c445783e5f19bb4f19e"><td class="memItemLeft" align="right" valign="top"><a id="a8d4fb163aeaf9c445783e5f19bb4f19e" name="a8d4fb163aeaf9c445783e5f19bb4f19e"></a>
static plInt32&#160;</td><td class="memItemRight" valign="bottom"><b>RawByteCompare</b> (const void *a, const void *b, size_t uiNumBytesToCompare)</td></tr>
<tr class="memdesc:a8d4fb163aeaf9c445783e5f19bb4f19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares exactly <em>uiNumBytesToCompare</em> from <em>a</em> and <em>b</em>, independent of the involved types and their sizes. <br /></td></tr>
<tr class="separator:a8d4fb163aeaf9c445783e5f19bb4f19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b127801462e31890c28aac2d8bc4bf" id="r_a15b127801462e31890c28aac2d8bc4bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15b127801462e31890c28aac2d8bc4bf"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15b127801462e31890c28aac2d8bc4bf">AddByteOffset</a> (T *pPtr, std::ptrdiff_t offset)</td></tr>
<tr class="memdesc:a15b127801462e31890c28aac2d8bc4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address stored in <em>ptr</em> plus the given byte offset <em>iOffset</em>, cast to type <em>T</em>.  <br /></td></tr>
<tr class="separator:a15b127801462e31890c28aac2d8bc4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf7c4f708e620d0bd3ce78f685a1977" id="r_a2cf7c4f708e620d0bd3ce78f685a1977"><td class="memTemplParams" colspan="2"><a id="a2cf7c4f708e620d0bd3ce78f685a1977" name="a2cf7c4f708e620d0bd3ce78f685a1977"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cf7c4f708e620d0bd3ce78f685a1977"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignBackwards</b> (T *pPtr, size_t uiAlignment)</td></tr>
<tr class="memdesc:a2cf7c4f708e620d0bd3ce78f685a1977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the pointer <em>ptr</em> by moving its address backwards to the previous multiple of <em>uiAlignment</em>. <br /></td></tr>
<tr class="separator:a2cf7c4f708e620d0bd3ce78f685a1977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05761337cfbe0233d8c8897137b22d42" id="r_a05761337cfbe0233d8c8897137b22d42"><td class="memTemplParams" colspan="2"><a id="a05761337cfbe0233d8c8897137b22d42" name="a05761337cfbe0233d8c8897137b22d42"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05761337cfbe0233d8c8897137b22d42"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignForwards</b> (T *pPtr, size_t uiAlignment)</td></tr>
<tr class="memdesc:a05761337cfbe0233d8c8897137b22d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the pointer <em>ptr</em> by moving its address forwards to the next multiple of <em>uiAlignment</em>. <br /></td></tr>
<tr class="separator:a05761337cfbe0233d8c8897137b22d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac0ea8dc364f79d0ed4cf8c65ab0de" id="r_aebac0ea8dc364f79d0ed4cf8c65ab0de"><td class="memTemplParams" colspan="2"><a id="aebac0ea8dc364f79d0ed4cf8c65ab0de" name="aebac0ea8dc364f79d0ed4cf8c65ab0de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebac0ea8dc364f79d0ed4cf8c65ab0de"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlignSize</b> (T uiSize, T uiAlignment)</td></tr>
<tr class="memdesc:aebac0ea8dc364f79d0ed4cf8c65ab0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the given size <em>uiSize</em> by rounding up to the next multiple of the size. <br /></td></tr>
<tr class="separator:aebac0ea8dc364f79d0ed4cf8c65ab0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9adef6f30af3d9e6e592657784023" id="r_ad0e9adef6f30af3d9e6e592657784023"><td class="memTemplParams" colspan="2"><a id="ad0e9adef6f30af3d9e6e592657784023" name="ad0e9adef6f30af3d9e6e592657784023"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0e9adef6f30af3d9e6e592657784023"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsAligned</b> (const T *pPtr, size_t uiAlignment)</td></tr>
<tr class="memdesc:ad0e9adef6f30af3d9e6e592657784023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>ptr</em> is aligned to a memory address that is a multiple of <em>uiAlignment</em>. <br /></td></tr>
<tr class="separator:ad0e9adef6f30af3d9e6e592657784023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85af144b5babe0bc72fb443bfce08f7c" id="r_a85af144b5babe0bc72fb443bfce08f7c"><td class="memTemplParams" colspan="2"><a id="a85af144b5babe0bc72fb443bfce08f7c" name="a85af144b5babe0bc72fb443bfce08f7c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85af144b5babe0bc72fb443bfce08f7c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsSizeAligned</b> (T uiSize, T uiAlignment)</td></tr>
<tr class="memdesc:a85af144b5babe0bc72fb443bfce08f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given size is aligned. <br /></td></tr>
<tr class="separator:a85af144b5babe0bc72fb443bfce08f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bc8fa24ddbd2aa74827d0de2e5195d" id="r_a48bc8fa24ddbd2aa74827d0de2e5195d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48bc8fa24ddbd2aa74827d0de2e5195d">ReserveLower4GBAddressSpace</a> ()</td></tr>
<tr class="memdesc:a48bc8fa24ddbd2aa74827d0de2e5195d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves the lower 4GB of address space in 64-bit builds to ensure all allocations start above 4GB.  <br /></td></tr>
<tr class="separator:a48bc8fa24ddbd2aa74827d0de2e5195d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides functions to work on raw memory. </p>
<p>The following concepts are realized: Copy: Copying a object from a to b means that two equivalent objects will exists in both a and b. Move: Moving an object from a to b means that the object will exist in b afterwards but a will be empty afterwards, but not destructed. This strictly requires an available move constructor (compile error otherwise). Relocate: Relocating an object from a to b means that the object will exist in b afterwards but will no longer exist in a, which means a will be moved if available or copied, but destructed afterwards in any case. Construct: Constructing assumes that the destination does not contain a valid object. Overlapped: The source and destination range may overlap for the operation to be performed. The above mentioned concepts can be combined, e.g. RelocateConstruct for relocating to an uninitialized buffer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a15b127801462e31890c28aac2d8bc4bf" name="a15b127801462e31890c28aac2d8bc4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b127801462e31890c28aac2d8bc4bf">&#9670;&#160;</a></span>AddByteOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T * plMemoryUtils::AddByteOffset </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the address stored in <em>ptr</em> plus the given byte offset <em>iOffset</em>, cast to type <em>T</em>. </p>
<p>This is useful when working with raw memory, to safely modify a pointer without having to take care of the details of pointer arithmetic. </p>

</div>
</div>
<a id="a611d82f77f3c825a296d39e2bfa3b1c6" name="a611d82f77f3c825a296d39e2bfa3b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d82f77f3c825a296d39e2bfa3b1c6">&#9670;&#160;</a></span>Construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;plConstructionMode mode, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void plMemoryUtils::Construct </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pDestination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uiCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs <em>uiCount</em> objects of type T in a raw buffer at <em>pDestination</em>. </p>
<p>The plConstructionMode template argument determines whether trivial types will be skipped. </p>

</div>
</div>
<a id="a9a74df0cde5a8c8012d7b6c48d3d8729" name="a9a74df0cde5a8c8012d7b6c48d3d8729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74df0cde5a8c8012d7b6c48d3d8729">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void plMemoryUtils::Copy </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pDestination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>pSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uiCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies objects of type T from <em>pSource</em> to <em>pDestination</em>. </p>
<p>If the two buffers overlap use CopyOverlapped instead. </p>

</div>
</div>
<a id="ad95431ce4b94b94c62927ef693d82b18" name="ad95431ce4b94b94c62927ef693d82b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95431ce4b94b94c62927ef693d82b18">&#9670;&#160;</a></span>CopyOverlapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void plMemoryUtils::CopyOverlapped </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pDestination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>pSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uiCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies objects of type T from <em>pSource</em> to <em>pDestination</em>. </p>
<p>The two buffers may overlap when using this method. </p>

</div>
</div>
<a id="ad644c6cd5636810d5218474fa2b478c5" name="ad644c6cd5636810d5218474fa2b478c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad644c6cd5636810d5218474fa2b478c5">&#9670;&#160;</a></span>RelocateOverlapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void plMemoryUtils::RelocateOverlapped </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pDestination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>pSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uiCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves objects of type T from <em>pSource</em> to <em>pDestination</em>. </p>
<p>The two buffers may overlap when using this method. </p>

</div>
</div>
<a id="a48bc8fa24ddbd2aa74827d0de2e5195d" name="a48bc8fa24ddbd2aa74827d0de2e5195d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bc8fa24ddbd2aa74827d0de2e5195d">&#9670;&#160;</a></span>ReserveLower4GBAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plMemoryUtils::ReserveLower4GBAddressSpace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves the lower 4GB of address space in 64-bit builds to ensure all allocations start above 4GB. </p>
<dl class="section note"><dt>Note</dt><dd>Note that this does NOT reserve 4GB of RAM, only address space. This can help to detect pointer truncation. In 32-bit builds it does nothing.</dd></dl>
<p>Currently only implemented on Windows. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Engine/Foundation/Memory/<a class="el" href="../../da/d0b/_memory_utils_8h_source.htm">MemoryUtils.h</a></li>
<li>Code/Engine/Foundation/Memory/Implementation/<b>MemoryUtils.cpp</b></li>
<li>Code/Engine/Foundation/Memory/Implementation/<a class="el" href="../../d3/de9/_memory_utils__inl_8h_source.htm">MemoryUtils_inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../df/d4d/classpl_memory_utils.htm">plMemoryUtils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
