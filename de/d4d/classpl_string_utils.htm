<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>plEngine: plStringUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../pl-logo-64.png"/></td>
  <td id="projectalign">
   <div id="projectname">plEngine<span id="projectnumber">&#160;Release 2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.htm');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.htm','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d4d/classpl_string_utils.htm','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../de/da4/classpl_string_utils-members.htm">List of all members</a>  </div>
  <div class="headertitle"><div class="title">plStringUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Helper functions to work with UTF-8 strings (which include pure ASCII strings)  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8bc7e3a526fc09382eaa1276895f3266" id="r_a8bc7e3a526fc09382eaa1276895f3266"><td class="memItemLeft" align="right" valign="top"><a id="a8bc7e3a526fc09382eaa1276895f3266" name="a8bc7e3a526fc09382eaa1276895f3266"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PL_CHARACTER_FILTER</b> = bool (*)(plUInt32 uiChar)</td></tr>
<tr class="memdesc:a8bc7e3a526fc09382eaa1276895f3266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Definition for a function that determines whether a (Utf32) character belongs to a certain category of characters. <br /></td></tr>
<tr class="separator:a8bc7e3a526fc09382eaa1276895f3266"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61dc3b50d1a84532a2ac032cc45407c5" id="r_a61dc3b50d1a84532a2ac032cc45407c5"><td class="memTemplParams" colspan="2"><a id="a61dc3b50d1a84532a2ac032cc45407c5" name="a61dc3b50d1a84532a2ac032cc45407c5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61dc3b50d1a84532a2ac032cc45407c5"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString)</td></tr>
<tr class="separator:a61dc3b50d1a84532a2ac032cc45407c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2077f8630a5b156156934ae32848175" id="r_aa2077f8630a5b156156934ae32848175"><td class="memTemplParams" colspan="2"><a id="aa2077f8630a5b156156934ae32848175" name="aa2077f8630a5b156156934ae32848175"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2077f8630a5b156156934ae32848175"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="separator:aa2077f8630a5b156156934ae32848175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e91a31a4a0f499b2a90c943750e79" id="r_ae08e91a31a4a0f499b2a90c943750e79"><td class="memTemplParams" colspan="2"><a id="ae08e91a31a4a0f499b2a90c943750e79" name="ae08e91a31a4a0f499b2a90c943750e79"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae08e91a31a4a0f499b2a90c943750e79"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UpdateStringEnd</b> (const T *pStringStart, const T *&amp;ref_pStringEnd)</td></tr>
<tr class="separator:ae08e91a31a4a0f499b2a90c943750e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af3e32769f27383ebd20d9cb1d581be91" id="r_af3e32769f27383ebd20d9cb1d581be91"><td class="memTemplParams" colspan="2"><a id="af3e32769f27383ebd20d9cb1d581be91" name="af3e32769f27383ebd20d9cb1d581be91"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3e32769f27383ebd20d9cb1d581be91"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString)</td></tr>
<tr class="memdesc:af3e32769f27383ebd20d9cb1d581be91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:af3e32769f27383ebd20d9cb1d581be91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba220b6de21a2bb1570d56732181ca" id="r_a58ba220b6de21a2bb1570d56732181ca"><td class="memTemplParams" colspan="2"><a id="a58ba220b6de21a2bb1570d56732181ca" name="a58ba220b6de21a2bb1570d56732181ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58ba220b6de21a2bb1570d56732181ca"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:a58ba220b6de21a2bb1570d56732181ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer, is equal to its end or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:a58ba220b6de21a2bb1570d56732181ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a534d013b4c7d0572c8315dbf22d25b" id="r_a4a534d013b4c7d0572c8315dbf22d25b"><td class="memTemplParams" colspan="2"><a id="a4a534d013b4c7d0572c8315dbf22d25b" name="a4a534d013b4c7d0572c8315dbf22d25b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a534d013b4c7d0572c8315dbf22d25b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UpdateStringEnd</b> (const T *pStringStart, const T *&amp;ref_pStringEnd)</td></tr>
<tr class="memdesc:a4a534d013b4c7d0572c8315dbf22d25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the end pointer of a string (<em>szStringEnd</em>), if that is currently set to plMaxStringEnd. Otherwise does nothing. <br /></td></tr>
<tr class="separator:a4a534d013b4c7d0572c8315dbf22d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a530c871d242106cf46b9bd5b676a2" id="r_ab5a530c871d242106cf46b9bd5b676a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5a530c871d242106cf46b9bd5b676a2"><td class="memTemplItemLeft" align="right" valign="top">static constexpr plUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5a530c871d242106cf46b9bd5b676a2">GetStringElementCount</a> (const T *pString)</td></tr>
<tr class="memdesc:ab5a530c871d242106cf46b9bd5b676a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <br /></td></tr>
<tr class="separator:ab5a530c871d242106cf46b9bd5b676a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a0908335cf5e1664be2957309e0f41" id="r_a18a0908335cf5e1664be2957309e0f41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18a0908335cf5e1664be2957309e0f41"><td class="memTemplItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18a0908335cf5e1664be2957309e0f41">GetStringElementCount</a> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:a18a0908335cf5e1664be2957309e0f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <br /></td></tr>
<tr class="separator:a18a0908335cf5e1664be2957309e0f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62540cef4e31838952f7cfc846ef9f2" id="r_ad62540cef4e31838952f7cfc846ef9f2"><td class="memItemLeft" align="right" valign="top"><a id="ad62540cef4e31838952f7cfc846ef9f2" name="ad62540cef4e31838952f7cfc846ef9f2"></a>
static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><b>GetCharacterCount</b> (const char *szUtf8, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ad62540cef4e31838952f7cfc846ef9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters (not Bytes!) in a Utf8 string (excluding the zero terminator), until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:ad62540cef4e31838952f7cfc846ef9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b21398e9e2ebf75f9f501accb2c7e3" id="r_ae7b21398e9e2ebf75f9f501accb2c7e3"><td class="memItemLeft" align="right" valign="top"><a id="ae7b21398e9e2ebf75f9f501accb2c7e3" name="ae7b21398e9e2ebf75f9f501accb2c7e3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>GetCharacterAndElementCount</b> (const char *szUtf8, plUInt32 &amp;ref_uiCharacterCount, plUInt32 &amp;ref_uiElementCount, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ae7b21398e9e2ebf75f9f501accb2c7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns both the number of characters and the number of bytes in a Utf8 string, until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:ae7b21398e9e2ebf75f9f501accb2c7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3171be9af59ccd6faa74055858e3a60" id="r_ae3171be9af59ccd6faa74055858e3a60"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3171be9af59ccd6faa74055858e3a60">Copy</a> (char *szDest, plUInt32 uiDstSize, const char *szSource, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ae3171be9af59ccd6faa74055858e3a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes.  <br /></td></tr>
<tr class="separator:ae3171be9af59ccd6faa74055858e3a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b297cba40ffa5019cc0233ba797ccc" id="r_a13b297cba40ffa5019cc0233ba797ccc"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b297cba40ffa5019cc0233ba797ccc">CopyN</a> (char *szDest, plUInt32 uiDstSize, const char *szSource, plUInt32 uiCharsToCopy, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a13b297cba40ffa5019cc0233ba797ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes.  <br /></td></tr>
<tr class="separator:a13b297cba40ffa5019cc0233ba797ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad738a4f07b1860528fe3bea806dc4ed1" id="r_ad738a4f07b1860528fe3bea806dc4ed1"><td class="memItemLeft" align="right" valign="top"><a id="ad738a4f07b1860528fe3bea806dc4ed1" name="ad738a4f07b1860528fe3bea806dc4ed1"></a>
static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><b>ToUpperChar</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:ad738a4f07b1860528fe3bea806dc4ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper case code point for uiChar. <br /></td></tr>
<tr class="separator:ad738a4f07b1860528fe3bea806dc4ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d67b2d9cd576d2e23668015dc0ce88c" id="r_a2d67b2d9cd576d2e23668015dc0ce88c"><td class="memItemLeft" align="right" valign="top"><a id="a2d67b2d9cd576d2e23668015dc0ce88c" name="a2d67b2d9cd576d2e23668015dc0ce88c"></a>
static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><b>ToLowerChar</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:a2d67b2d9cd576d2e23668015dc0ce88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower case code point for uiChar. <br /></td></tr>
<tr class="separator:a2d67b2d9cd576d2e23668015dc0ce88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4298ad9140576729bb32b7f70c9e71" id="r_aef4298ad9140576729bb32b7f70c9e71"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef4298ad9140576729bb32b7f70c9e71">ToUpperString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aef4298ad9140576729bb32b7f70c9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to upper case.  <br /></td></tr>
<tr class="separator:aef4298ad9140576729bb32b7f70c9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b1621cbd8468cd17c7e662e0187b3" id="r_ad63b1621cbd8468cd17c7e662e0187b3"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad63b1621cbd8468cd17c7e662e0187b3">ToLowerString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ad63b1621cbd8468cd17c7e662e0187b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to lower case.  <br /></td></tr>
<tr class="separator:ad63b1621cbd8468cd17c7e662e0187b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccac70b4088fb22a1672c0b218b521c" id="r_a4ccac70b4088fb22a1672c0b218b521c"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ccac70b4088fb22a1672c0b218b521c">CompareChars</a> (plUInt32 uiCharacter1, plUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:a4ccac70b4088fb22a1672c0b218b521c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality.  <br /></td></tr>
<tr class="separator:a4ccac70b4088fb22a1672c0b218b521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e3115137a813c8e4600c6110fac599" id="r_ae6e3115137a813c8e4600c6110fac599"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e3115137a813c8e4600c6110fac599">CompareChars</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:ae6e3115137a813c8e4600c6110fac599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality.  <br /></td></tr>
<tr class="separator:ae6e3115137a813c8e4600c6110fac599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22210caae00b66f1f02b4affe722fd6d" id="r_a22210caae00b66f1f02b4affe722fd6d"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22210caae00b66f1f02b4affe722fd6d">CompareChars_NoCase</a> (plUInt32 uiCharacter1, plUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:a22210caae00b66f1f02b4affe722fd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality, case-insensitive.  <br /></td></tr>
<tr class="separator:a22210caae00b66f1f02b4affe722fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ebe92d8c561fb3921350a35cbaf9dc" id="r_ac4ebe92d8c561fb3921350a35cbaf9dc"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4ebe92d8c561fb3921350a35cbaf9dc">CompareChars_NoCase</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:ac4ebe92d8c561fb3921350a35cbaf9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality, case-insensitive.  <br /></td></tr>
<tr class="separator:ac4ebe92d8c561fb3921350a35cbaf9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ffb499352fde674181a35aebd1f2d" id="r_a078ffb499352fde674181a35aebd1f2d"><td class="memItemLeft" align="right" valign="top"><a id="a078ffb499352fde674181a35aebd1f2d" name="a078ffb499352fde674181a35aebd1f2d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEqual</b> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a078ffb499352fde674181a35aebd1f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise). <br /></td></tr>
<tr class="separator:a078ffb499352fde674181a35aebd1f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00c3c3256411a9f615f03aaa6caca7" id="r_aba00c3c3256411a9f615f03aaa6caca7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba00c3c3256411a9f615f03aaa6caca7">IsEqualN</a> (const char *pString1, const char *pString2, plUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aba00c3c3256411a9f615f03aaa6caca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise) up to the n-th character.  <br /></td></tr>
<tr class="separator:aba00c3c3256411a9f615f03aaa6caca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a5be3ff9db439a31a48affe41ddc52" id="r_a27a5be3ff9db439a31a48affe41ddc52"><td class="memItemLeft" align="right" valign="top"><a id="a27a5be3ff9db439a31a48affe41ddc52" name="a27a5be3ff9db439a31a48affe41ddc52"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEqual_NoCase</b> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a27a5be3ff9db439a31a48affe41ddc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive). <br /></td></tr>
<tr class="separator:a27a5be3ff9db439a31a48affe41ddc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab090c9d993e98ea7a05e581932146ad1" id="r_ab090c9d993e98ea7a05e581932146ad1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab090c9d993e98ea7a05e581932146ad1">IsEqualN_NoCase</a> (const char *pString1, const char *pString2, plUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ab090c9d993e98ea7a05e581932146ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive) up to the n-th character.  <br /></td></tr>
<tr class="separator:ab090c9d993e98ea7a05e581932146ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b21ecc35f92bff6ff21d0822077eaa6" id="r_a7b21ecc35f92bff6ff21d0822077eaa6"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b21ecc35f92bff6ff21d0822077eaa6">Compare</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a7b21ecc35f92bff6ff21d0822077eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality.  <br /></td></tr>
<tr class="separator:a7b21ecc35f92bff6ff21d0822077eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aeb4d20b7672aea4e05fa163244cca" id="r_a22aeb4d20b7672aea4e05fa163244cca"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22aeb4d20b7672aea4e05fa163244cca">CompareN</a> (const char *pString1, const char *pString2, plUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a22aeb4d20b7672aea4e05fa163244cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality.  <br /></td></tr>
<tr class="separator:a22aeb4d20b7672aea4e05fa163244cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ab9e86704a1d319a455456d2d8ab94" id="r_a07ab9e86704a1d319a455456d2d8ab94"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07ab9e86704a1d319a455456d2d8ab94">Compare_NoCase</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a07ab9e86704a1d319a455456d2d8ab94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality, case-insensitive.  <br /></td></tr>
<tr class="separator:a07ab9e86704a1d319a455456d2d8ab94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267c56a514681d441d714a70e12f3d0a" id="r_a267c56a514681d441d714a70e12f3d0a"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a267c56a514681d441d714a70e12f3d0a">CompareN_NoCase</a> (const char *pString1, const char *pString2, plUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a267c56a514681d441d714a70e12f3d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive.  <br /></td></tr>
<tr class="separator:a267c56a514681d441d714a70e12f3d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c47ebe8153b5c2a5178e6354e3404c" id="r_a20c47ebe8153b5c2a5178e6354e3404c"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c47ebe8153b5c2a5178e6354e3404c">snprintf</a> (char *szDst, plUInt32 uiDstSize, const char *szFormat,...)</td></tr>
<tr class="memdesc:a20c47ebe8153b5c2a5178e6354e3404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <br /></td></tr>
<tr class="separator:a20c47ebe8153b5c2a5178e6354e3404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49b80a2014c61abb77c4404fbd64166" id="r_aa49b80a2014c61abb77c4404fbd64166"><td class="memItemLeft" align="right" valign="top">static plInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa49b80a2014c61abb77c4404fbd64166">vsnprintf</a> (char *szDst, plUInt32 uiDstSize, const char *szFormat, va_list szAp)</td></tr>
<tr class="memdesc:aa49b80a2014c61abb77c4404fbd64166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <br /></td></tr>
<tr class="separator:aa49b80a2014c61abb77c4404fbd64166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b49002e90a4951b887735c06800981" id="r_aa1b49002e90a4951b887735c06800981"><td class="memItemLeft" align="right" valign="top"><a id="aa1b49002e90a4951b887735c06800981" name="aa1b49002e90a4951b887735c06800981"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartsWith</b> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aa1b49002e90a4951b887735c06800981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. <br /></td></tr>
<tr class="separator:aa1b49002e90a4951b887735c06800981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfa42149d0d8b134bd0821c31c35b5e" id="r_aecfa42149d0d8b134bd0821c31c35b5e"><td class="memItemLeft" align="right" valign="top"><a id="aecfa42149d0d8b134bd0821c31c35b5e" name="aecfa42149d0d8b134bd0821c31c35b5e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartsWith_NoCase</b> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aecfa42149d0d8b134bd0821c31c35b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. Ignores case. <br /></td></tr>
<tr class="separator:aecfa42149d0d8b134bd0821c31c35b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838eada49316bf517333d30ec38d3b4c" id="r_a838eada49316bf517333d30ec38d3b4c"><td class="memItemLeft" align="right" valign="top"><a id="a838eada49316bf517333d30ec38d3b4c" name="a838eada49316bf517333d30ec38d3b4c"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>EndsWith</b> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a838eada49316bf517333d30ec38d3b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. <br /></td></tr>
<tr class="separator:a838eada49316bf517333d30ec38d3b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30321cef0e930af1a5f510d85eb82e" id="r_a4d30321cef0e930af1a5f510d85eb82e"><td class="memItemLeft" align="right" valign="top"><a id="a4d30321cef0e930af1a5f510d85eb82e" name="a4d30321cef0e930af1a5f510d85eb82e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>EndsWith_NoCase</b> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a4d30321cef0e930af1a5f510d85eb82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. Ignores case. <br /></td></tr>
<tr class="separator:a4d30321cef0e930af1a5f510d85eb82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b8e9f8cd1a2821d8dad1e050ed6f77" id="r_a57b8e9f8cd1a2821d8dad1e050ed6f77"><td class="memItemLeft" align="right" valign="top"><a id="a57b8e9f8cd1a2821d8dad1e050ed6f77" name="a57b8e9f8cd1a2821d8dad1e050ed6f77"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindSubString</b> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a57b8e9f8cd1a2821d8dad1e050ed6f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. <br /></td></tr>
<tr class="separator:a57b8e9f8cd1a2821d8dad1e050ed6f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377e785747082b885661b4be55481134" id="r_a377e785747082b885661b4be55481134"><td class="memItemLeft" align="right" valign="top"><a id="a377e785747082b885661b4be55481134" name="a377e785747082b885661b4be55481134"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindSubString_NoCase</b> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a377e785747082b885661b4be55481134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. Ignores case. <br /></td></tr>
<tr class="separator:a377e785747082b885661b4be55481134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91a8556266df1ec41400e10c7430914" id="r_ae91a8556266df1ec41400e10c7430914"><td class="memItemLeft" align="right" valign="top"><a id="ae91a8556266df1ec41400e10c7430914" name="ae91a8556266df1ec41400e10c7430914"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindLastSubString</b> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ae91a8556266df1ec41400e10c7430914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. <br /></td></tr>
<tr class="separator:ae91a8556266df1ec41400e10c7430914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00851da0fe9a6a1a1f9383befb50820" id="r_ac00851da0fe9a6a1a1f9383befb50820"><td class="memItemLeft" align="right" valign="top"><a id="ac00851da0fe9a6a1a1f9383befb50820" name="ac00851da0fe9a6a1a1f9383befb50820"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindLastSubString_NoCase</b> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ac00851da0fe9a6a1a1f9383befb50820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. Ignores case. <br /></td></tr>
<tr class="separator:ac00851da0fe9a6a1a1f9383befb50820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1987f56fa64976ca716d3ff565db1b58" id="r_a1987f56fa64976ca716d3ff565db1b58"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1987f56fa64976ca716d3ff565db1b58">SkipCharacters</a> (const char *szString, <a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a> skipCharacterCB, bool bAlwaysSkipFirst=false)</td></tr>
<tr class="memdesc:a1987f56fa64976ca716d3ff565db1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts at szString and advances to the next character for which SkipCharacterCB returns false;.  <br /></td></tr>
<tr class="separator:a1987f56fa64976ca716d3ff565db1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8c4b1d4927263dfaf7fb8eaf491168" id="r_a6c8c4b1d4927263dfaf7fb8eaf491168"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c8c4b1d4927263dfaf7fb8eaf491168">FindWordEnd</a> (const char *szString, <a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a> isDelimiterCB, bool bAlwaysSkipFirst=true)</td></tr>
<tr class="memdesc:a6c8c4b1d4927263dfaf7fb8eaf491168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in szString at which <em>IsDelimiterCB</em> returns true.  <br /></td></tr>
<tr class="separator:a6c8c4b1d4927263dfaf7fb8eaf491168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2e813f25f2a54a79d2084df96726c7" id="r_aeb2e813f25f2a54a79d2084df96726c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb2e813f25f2a54a79d2084df96726c7">Trim</a> (const char *&amp;ref_pString, const char *&amp;ref_pStringEnd, const char *szTrimCharsStart, const char *szTrimCharsEnd)</td></tr>
<tr class="memdesc:aeb2e813f25f2a54a79d2084df96726c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string.  <br /></td></tr>
<tr class="separator:aeb2e813f25f2a54a79d2084df96726c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8659e9d90e56e70ff6ae17d1b7a7e572" id="r_a8659e9d90e56e70ff6ae17d1b7a7e572"><td class="memItemLeft" align="right" valign="top"><a id="a8659e9d90e56e70ff6ae17d1b7a7e572" name="a8659e9d90e56e70ff6ae17d1b7a7e572"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsWhiteSpace</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:a8659e9d90e56e70ff6ae17d1b7a7e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function that returns true for ' ' (space), '\r' (carriage return), '<br  />
' (newline), '\t' (tab) and '\v' (vertical tab) <br /></td></tr>
<tr class="separator:a8659e9d90e56e70ff6ae17d1b7a7e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a5213e2eaffcc132054da990814753" id="r_a71a5213e2eaffcc132054da990814753"><td class="memItemLeft" align="right" valign="top"><a id="a71a5213e2eaffcc132054da990814753" name="a71a5213e2eaffcc132054da990814753"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDecimalDigit</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:a71a5213e2eaffcc132054da990814753"><td class="mdescLeft">&#160;</td><td class="mdescRight">A decimal digit from 0..9. <br /></td></tr>
<tr class="separator:a71a5213e2eaffcc132054da990814753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f929e7c423259efcfae8fca1b9c4ba0" id="r_a7f929e7c423259efcfae8fca1b9c4ba0"><td class="memItemLeft" align="right" valign="top"><a id="a7f929e7c423259efcfae8fca1b9c4ba0" name="a7f929e7c423259efcfae8fca1b9c4ba0"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsHexDigit</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:a7f929e7c423259efcfae8fca1b9c4ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hexadecimal digit from 0..F. <br /></td></tr>
<tr class="separator:a7f929e7c423259efcfae8fca1b9c4ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa164ac3b5b0ee167f3afb6ec9465547a" id="r_aa164ac3b5b0ee167f3afb6ec9465547a"><td class="memItemLeft" align="right" valign="top"><a id="aa164ac3b5b0ee167f3afb6ec9465547a" name="aa164ac3b5b0ee167f3afb6ec9465547a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsWordDelimiter_English</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:aa164ac3b5b0ee167f3afb6ec9465547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for English text. <br /></td></tr>
<tr class="separator:aa164ac3b5b0ee167f3afb6ec9465547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39784f6574ecbaf2062a29ecb79193a8" id="r_a39784f6574ecbaf2062a29ecb79193a8"><td class="memItemLeft" align="right" valign="top"><a id="a39784f6574ecbaf2062a29ecb79193a8" name="a39784f6574ecbaf2062a29ecb79193a8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIdentifierDelimiter_C_Code</b> (plUInt32 uiChar)</td></tr>
<tr class="memdesc:a39784f6574ecbaf2062a29ecb79193a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for identifiers in C code. <br /></td></tr>
<tr class="separator:a39784f6574ecbaf2062a29ecb79193a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdfebdd0899aed6b759afc40fa35ff3" id="r_aabdfebdd0899aed6b759afc40fa35ff3"><td class="memItemLeft" align="right" valign="top"><a id="aabdfebdd0899aed6b759afc40fa35ff3" name="aabdfebdd0899aed6b759afc40fa35ff3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsValidIdentifierName</b> (const char *pString, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aabdfebdd0899aed6b759afc40fa35ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given string is a valid identifier name in C code, ie has no white-spaces, starts with a literal etc. <br /></td></tr>
<tr class="separator:aabdfebdd0899aed6b759afc40fa35ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36ed6f5d73d409049c30c993f999a2" id="r_aeb36ed6f5d73d409049c30c993f999a2"><td class="memItemLeft" align="right" valign="top"><a id="aeb36ed6f5d73d409049c30c993f999a2" name="aeb36ed6f5d73d409049c30c993f999a2"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindWholeWord</b> (const char *szString, const char *szSearchFor, <a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a> isDelimiterCB, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aeb36ed6f5d73d409049c30c993f999a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. <br /></td></tr>
<tr class="separator:aeb36ed6f5d73d409049c30c993f999a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7534b7f3c1b300505e8d7fe356520d2f" id="r_a7534b7f3c1b300505e8d7fe356520d2f"><td class="memItemLeft" align="right" valign="top"><a id="a7534b7f3c1b300505e8d7fe356520d2f" name="a7534b7f3c1b300505e8d7fe356520d2f"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>FindWholeWord_NoCase</b> (const char *szString, const char *szSearchFor, <a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a> isDelimiterCB, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a7534b7f3c1b300505e8d7fe356520d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. Ignores case. <br /></td></tr>
<tr class="separator:a7534b7f3c1b300505e8d7fe356520d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c29b31db4088c95fb62e599295c6e" id="r_ad43c29b31db4088c95fb62e599295c6e"><td class="memItemLeft" align="right" valign="top"><a id="ad43c29b31db4088c95fb62e599295c6e" name="ad43c29b31db4088c95fb62e599295c6e"></a>
static <a class="el" href="../../da/dce/structpl_result.htm">plResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindUIntAtTheEnd</b> (const char *szString, plUInt32 &amp;out_uiValue, plUInt32 *pStringLengthBeforeUInt=nullptr)</td></tr>
<tr class="memdesc:ad43c29b31db4088c95fb62e599295c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given szString ends with an unsigned integer (e.g. "MyString123"). If pStringLengthBeforeUInt is non-null the string length up to the first digit is stored. Returns PL_SUCCESS if there is a value at the end of string, PL_FAILURE otherwise. <br /></td></tr>
<tr class="separator:ad43c29b31db4088c95fb62e599295c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c948aef01026a95390d129321863119" id="r_a9c948aef01026a95390d129321863119"><td class="memItemLeft" align="right" valign="top"><a id="a9c948aef01026a95390d129321863119" name="a9c948aef01026a95390d129321863119"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>OutputFormattedInt</b> (char *szOutputBuffer, plUInt32 uiBufferSize, plUInt32 &amp;ref_uiWritePos, plInt64 value, plUInt8 uiWidth, bool bPadZeros, plUInt8 uiBase)</td></tr>
<tr class="memdesc:a9c948aef01026a95390d129321863119"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a9c948aef01026a95390d129321863119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782a845cbcb962c0b834a4c277c297f7" id="r_a782a845cbcb962c0b834a4c277c297f7"><td class="memItemLeft" align="right" valign="top"><a id="a782a845cbcb962c0b834a4c277c297f7" name="a782a845cbcb962c0b834a4c277c297f7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>OutputFormattedUInt</b> (char *szOutputBuffer, plUInt32 uiBufferSize, plUInt32 &amp;ref_uiWritePos, plUInt64 value, plUInt8 uiWidth, bool bPadZeros, plUInt8 uiBase, bool bUpperCase)</td></tr>
<tr class="memdesc:a782a845cbcb962c0b834a4c277c297f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a782a845cbcb962c0b834a4c277c297f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2e890b961ca94183ba98a660e0f85" id="r_a2de2e890b961ca94183ba98a660e0f85"><td class="memItemLeft" align="right" valign="top"><a id="a2de2e890b961ca94183ba98a660e0f85" name="a2de2e890b961ca94183ba98a660e0f85"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>OutputFormattedFloat</b> (char *szOutputBuffer, plUInt32 uiBufferSize, plUInt32 &amp;ref_uiWritePos, double value, plUInt8 uiWidth, bool bPadZeros, plInt8 iPrecision, bool bScientific, bool bRemoveTrailingZeroes=false)</td></tr>
<tr class="memdesc:a2de2e890b961ca94183ba98a660e0f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a2de2e890b961ca94183ba98a660e0f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65ce3d2b47bd8abd02025c340a029e9" id="r_ab65ce3d2b47bd8abd02025c340a029e9"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab65ce3d2b47bd8abd02025c340a029e9">CalculateLineNumber</a> (const char *szString, const char *szOffset, const char *pStringEnd=<a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ab65ce3d2b47bd8abd02025c340a029e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates in which line number szOffset is in the given string.  <br /></td></tr>
<tr class="separator:ab65ce3d2b47bd8abd02025c340a029e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper functions to work with UTF-8 strings (which include pure ASCII strings) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab65ce3d2b47bd8abd02025c340a029e9" name="ab65ce3d2b47bd8abd02025c340a029e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65ce3d2b47bd8abd02025c340a029e9">&#9670;&#160;</a></span>CalculateLineNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::CalculateLineNumber </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pStringEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates in which line number szOffset is in the given string. </p>
<p>Line numbers are 1-based. Returns 0, if szOffset is outside the given string. </p>

</div>
</div>
<a id="a7b21ecc35f92bff6ff21d0822077eaa6" name="a7b21ecc35f92bff6ff21d0822077eaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b21ecc35f92bff6ff21d0822077eaa6">&#9670;&#160;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::Compare </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a07ab9e86704a1d319a455456d2d8ab94" name="a07ab9e86704a1d319a455456d2d8ab94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ab9e86704a1d319a455456d2d8ab94">&#9670;&#160;</a></span>Compare_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::Compare_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="ae6e3115137a813c8e4600c6110fac599" name="ae6e3115137a813c8e4600c6110fac599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e3115137a813c8e4600c6110fac599">&#9670;&#160;</a></span>CompareChars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szUtf8Char1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szUtf8Char2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a4ccac70b4088fb22a1672c0b218b521c" name="a4ccac70b4088fb22a1672c0b218b521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccac70b4088fb22a1672c0b218b521c">&#9670;&#160;</a></span>CompareChars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PL_ALWAYS_INLINE plInt32 plStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharacter1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharacter2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="ac4ebe92d8c561fb3921350a35cbaf9dc" name="ac4ebe92d8c561fb3921350a35cbaf9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ebe92d8c561fb3921350a35cbaf9dc">&#9670;&#160;</a></span>CompareChars_NoCase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szUtf8Char1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szUtf8Char2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality, case-insensitive. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a22210caae00b66f1f02b4affe722fd6d" name="a22210caae00b66f1f02b4affe722fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22210caae00b66f1f02b4affe722fd6d">&#9670;&#160;</a></span>CompareChars_NoCase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharacter1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharacter2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality, case-insensitive. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a22aeb4d20b7672aea4e05fa163244cca" name="a22aeb4d20b7672aea4e05fa163244cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22aeb4d20b7672aea4e05fa163244cca">&#9670;&#160;</a></span>CompareN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::CompareN </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharsToCompare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a267c56a514681d441d714a70e12f3d0a" name="a267c56a514681d441d714a70e12f3d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267c56a514681d441d714a70e12f3d0a">&#9670;&#160;</a></span>CompareN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plInt32 plStringUtils::CompareN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharsToCompare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="ae3171be9af59ccd6faa74055858e3a60" name="ae3171be9af59ccd6faa74055858e3a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3171be9af59ccd6faa74055858e3a60">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::Copy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szDest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiDstSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pSourceEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="a13b297cba40ffa5019cc0233ba797ccc" name="a13b297cba40ffa5019cc0233ba797ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b297cba40ffa5019cc0233ba797ccc">&#9670;&#160;</a></span>CopyN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::CopyN </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szDest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiDstSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharsToCopy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pSourceEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="a6c8c4b1d4927263dfaf7fb8eaf491168" name="a6c8c4b1d4927263dfaf7fb8eaf491168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8c4b1d4927263dfaf7fb8eaf491168">&#9670;&#160;</a></span>FindWordEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * plStringUtils::FindWordEnd </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a></td>          <td class="paramname"><span class="paramname"><em>isDelimiterCB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAlwaysSkipFirst</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in szString at which <em>IsDelimiterCB</em> returns true. </p>
<p>This is basically the inverse of SkipCharacters. SkipCharacters advances over all characters that fulfill the filter, FindWordEnd advances over all characters that do not fulfill it. </p>

</div>
</div>
<a id="ab5a530c871d242106cf46b9bd5b676a2" name="ab5a530c871d242106cf46b9bd5b676a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a530c871d242106cf46b9bd5b676a2">&#9670;&#160;</a></span>GetStringElementCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>pString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="a18a0908335cf5e1664be2957309e0f41" name="a18a0908335cf5e1664be2957309e0f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a0908335cf5e1664be2957309e0f41">&#9670;&#160;</a></span>GetStringElementCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>pString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>pStringEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="aba00c3c3256411a9f615f03aaa6caca7" name="aba00c3c3256411a9f615f03aaa6caca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba00c3c3256411a9f615f03aaa6caca7">&#9670;&#160;</a></span>IsEqualN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PL_ALWAYS_INLINE bool plStringUtils::IsEqualN </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharsToCompare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (bitwise) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="ab090c9d993e98ea7a05e581932146ad1" name="ab090c9d993e98ea7a05e581932146ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab090c9d993e98ea7a05e581932146ad1">&#9670;&#160;</a></span>IsEqualN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PL_ALWAYS_INLINE bool plStringUtils::IsEqualN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiCharsToCompare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString1End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pString2End</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (case-insensitive) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="a1987f56fa64976ca716d3ff565db1b58" name="a1987f56fa64976ca716d3ff565db1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1987f56fa64976ca716d3ff565db1b58">&#9670;&#160;</a></span>SkipCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * plStringUtils::SkipCharacters </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bc7e3a526fc09382eaa1276895f3266">PL_CHARACTER_FILTER</a></td>          <td class="paramname"><span class="paramname"><em>skipCharacterCB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAlwaysSkipFirst</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts at szString and advances to the next character for which SkipCharacterCB returns false;. </p>
<p>If <em>bAlwaysSkipFirst</em> is false and szString points to a character that does not fulfill the filter, this function will return immediately and nothing will change. If <em>bAlwaysSkipFirst</em> is true, the first character will always be skipped, regardless what it is (unless it is the zero terminator). The latter is useful to skip an entire word and get to the next word in a string.<br  />
 </p>

</div>
</div>
<a id="a20c47ebe8153b5c2a5178e6354e3404c" name="a20c47ebe8153b5c2a5178e6354e3404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c47ebe8153b5c2a5178e6354e3404c">&#9670;&#160;</a></span>snprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int plStringUtils::snprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiDstSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szFormat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<a id="ad63b1621cbd8468cd17c7e662e0187b3" name="ad63b1621cbd8468cd17c7e662e0187b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63b1621cbd8468cd17c7e662e0187b3">&#9670;&#160;</a></span>ToLowerString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::ToLowerString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pStringEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to lower case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="aef4298ad9140576729bb32b7f70c9e71" name="aef4298ad9140576729bb32b7f70c9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4298ad9140576729bb32b7f70c9e71">&#9670;&#160;</a></span>ToUpperString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plStringUtils::ToUpperString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pStringEnd</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d5/de1/classpl_unicode_utils.htm#a547a15418df6b0b46b539814fa426c69">plUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to upper case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="aeb2e813f25f2a54a79d2084df96726c7" name="aeb2e813f25f2a54a79d2084df96726c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2e813f25f2a54a79d2084df96726c7">&#9670;&#160;</a></span>Trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plStringUtils::Trim </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;</td>          <td class="paramname"><span class="paramname"><em>ref_pString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;</td>          <td class="paramname"><span class="paramname"><em>ref_pStringEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szTrimCharsStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szTrimCharsEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pString</td><td>The string to trim. </td></tr>
    <tr><td class="paramname">pStringEnd</td><td>The end pointer into pString, either the end pointer for the not zero terminated string or plMaxStringEnd for zero terminated ones.</td></tr>
    <tr><td class="paramname">szTrimCharsStart</td><td>A string compromised of characters to trim from the start of the string.</td></tr>
    <tr><td class="paramname">szTrimCharsEnd</td><td>A string compromised of characters to trim from the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49b80a2014c61abb77c4404fbd64166" name="aa49b80a2014c61abb77c4404fbd64166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49b80a2014c61abb77c4404fbd64166">&#9670;&#160;</a></span>vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int plStringUtils::vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>szDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiDstSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szFormat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>szAp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Engine/Foundation/Strings/<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a></li>
<li>Code/Engine/Foundation/Strings/Implementation/<b>snprintf.cpp</b></li>
<li>Code/Engine/Foundation/Strings/Implementation/<b>StringUtils.cpp</b></li>
<li>Code/Engine/Foundation/Strings/Implementation/<a class="el" href="../../d4/d13/_string_utils__inl_8h_source.htm">StringUtils_inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/d4d/classpl_string_utils.htm">plStringUtils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
