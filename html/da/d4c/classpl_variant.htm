<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Plasma Engine: plVariant Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../pl-logo-64.png"/></td>
  <td id="projectalign">
   <div id="projectname">Plasma Engine<span id="projectnumber">&#160;2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.htm');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.htm','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d4c/classpl_variant.htm','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../dd/d6c/classpl_variant-members.htm">List of all members</a>  </div>
  <div class="headertitle"><div class="title">plVariant Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../da/d4c/classpl_variant.htm" title="plVariant is a class that can store different types of variables, which is useful in situations where...">plVariant</a> is a class that can store different types of variables, which is useful in situations where it is not clear up front, which type of data will be passed around.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d19/_variant_8h_source.htm">Variant.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d90/structpl_variant_1_1_string_wrapper.htm">StringWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper struct to wrap a string pointer  <a href="../../d1/d90/structpl_variant_1_1_string_wrapper.htm#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a568aa288fd4752194fbfff1fc7df5b9e" id="r_a568aa288fd4752194fbfff1fc7df5b9e"><td class="memItemLeft" align="right" valign="top"><a id="a568aa288fd4752194fbfff1fc7df5b9e" name="a568aa288fd4752194fbfff1fc7df5b9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> = <a class="el" href="../../d6/d1e/structpl_variant_type.htm">plVariantType</a></td></tr>
<tr class="separator:a568aa288fd4752194fbfff1fc7df5b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fd6f364d4c66da92e5fc41b473fbb2" id="r_ac4fd6f364d4c66da92e5fc41b473fbb2"><td class="memTemplParams" colspan="2"><a id="ac4fd6f364d4c66da92e5fc41b473fbb2" name="ac4fd6f364d4c66da92e5fc41b473fbb2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4fd6f364d4c66da92e5fc41b473fbb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypeDeduction</b> = <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt;T&gt;</td></tr>
<tr class="separator:ac4fd6f364d4c66da92e5fc41b473fbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a171f21e027c38dfacf5431d7630ebdea" id="r_a171f21e027c38dfacf5431d7630ebdea"><td class="memItemLeft" align="right" valign="top"><a id="a171f21e027c38dfacf5431d7630ebdea" name="a171f21e027c38dfacf5431d7630ebdea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> ()</td></tr>
<tr class="memdesc:a171f21e027c38dfacf5431d7630ebdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the variant to be 'Invalid'. <br /></td></tr>
<tr class="separator:a171f21e027c38dfacf5431d7630ebdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada90bbbda7a21033b0e91f7b3492c555" id="r_ada90bbbda7a21033b0e91f7b3492c555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada90bbbda7a21033b0e91f7b3492c555">plVariant</a> (const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;other)</td></tr>
<tr class="memdesc:ada90bbbda7a21033b0e91f7b3492c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the other variant.  <br /></td></tr>
<tr class="separator:ada90bbbda7a21033b0e91f7b3492c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417bec50ab0a54a246b8aec9707e8797" id="r_a417bec50ab0a54a246b8aec9707e8797"><td class="memItemLeft" align="right" valign="top"><a id="a417bec50ab0a54a246b8aec9707e8797" name="a417bec50ab0a54a246b8aec9707e8797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (<a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a417bec50ab0a54a246b8aec9707e8797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the data from the other variant. <br /></td></tr>
<tr class="separator:a417bec50ab0a54a246b8aec9707e8797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66aa46bfbc153545d192876d8bdd0523" id="r_a66aa46bfbc153545d192876d8bdd0523"><td class="memItemLeft" align="right" valign="top"><a id="a66aa46bfbc153545d192876d8bdd0523" name="a66aa46bfbc153545d192876d8bdd0523"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const bool &amp;value)</td></tr>
<tr class="separator:a66aa46bfbc153545d192876d8bdd0523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b5f397cb78be2a334a0f9b04e81fa" id="r_a843b5f397cb78be2a334a0f9b04e81fa"><td class="memItemLeft" align="right" valign="top"><a id="a843b5f397cb78be2a334a0f9b04e81fa" name="a843b5f397cb78be2a334a0f9b04e81fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plInt8 &amp;value)</td></tr>
<tr class="separator:a843b5f397cb78be2a334a0f9b04e81fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae9d4ff110f71af541641becf409695" id="r_a4ae9d4ff110f71af541641becf409695"><td class="memItemLeft" align="right" valign="top"><a id="a4ae9d4ff110f71af541641becf409695" name="a4ae9d4ff110f71af541641becf409695"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plUInt8 &amp;value)</td></tr>
<tr class="separator:a4ae9d4ff110f71af541641becf409695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46906cc86e349b077920ff413dbb8458" id="r_a46906cc86e349b077920ff413dbb8458"><td class="memItemLeft" align="right" valign="top"><a id="a46906cc86e349b077920ff413dbb8458" name="a46906cc86e349b077920ff413dbb8458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plInt16 &amp;value)</td></tr>
<tr class="separator:a46906cc86e349b077920ff413dbb8458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435fd1d77b222224730e52498bd69b72" id="r_a435fd1d77b222224730e52498bd69b72"><td class="memItemLeft" align="right" valign="top"><a id="a435fd1d77b222224730e52498bd69b72" name="a435fd1d77b222224730e52498bd69b72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plUInt16 &amp;value)</td></tr>
<tr class="separator:a435fd1d77b222224730e52498bd69b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eece6c075926944706848282e45c10" id="r_a60eece6c075926944706848282e45c10"><td class="memItemLeft" align="right" valign="top"><a id="a60eece6c075926944706848282e45c10" name="a60eece6c075926944706848282e45c10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plInt32 &amp;value)</td></tr>
<tr class="separator:a60eece6c075926944706848282e45c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fc4a1842e41257da14d170544fddd6" id="r_a25fc4a1842e41257da14d170544fddd6"><td class="memItemLeft" align="right" valign="top"><a id="a25fc4a1842e41257da14d170544fddd6" name="a25fc4a1842e41257da14d170544fddd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plUInt32 &amp;value)</td></tr>
<tr class="separator:a25fc4a1842e41257da14d170544fddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aab763c4441b3f64390662c8843467" id="r_a58aab763c4441b3f64390662c8843467"><td class="memItemLeft" align="right" valign="top"><a id="a58aab763c4441b3f64390662c8843467" name="a58aab763c4441b3f64390662c8843467"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plInt64 &amp;value)</td></tr>
<tr class="separator:a58aab763c4441b3f64390662c8843467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2598420745469ff371fa3b265feefed" id="r_ab2598420745469ff371fa3b265feefed"><td class="memItemLeft" align="right" valign="top"><a id="ab2598420745469ff371fa3b265feefed" name="ab2598420745469ff371fa3b265feefed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const plUInt64 &amp;value)</td></tr>
<tr class="separator:ab2598420745469ff371fa3b265feefed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e21a702be52e68ab0d1b72e2e330c1" id="r_aa6e21a702be52e68ab0d1b72e2e330c1"><td class="memItemLeft" align="right" valign="top"><a id="aa6e21a702be52e68ab0d1b72e2e330c1" name="aa6e21a702be52e68ab0d1b72e2e330c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const float &amp;value)</td></tr>
<tr class="separator:aa6e21a702be52e68ab0d1b72e2e330c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30b907425b43d4d2496c8c9c6cc3efd" id="r_ae30b907425b43d4d2496c8c9c6cc3efd"><td class="memItemLeft" align="right" valign="top"><a id="ae30b907425b43d4d2496c8c9c6cc3efd" name="ae30b907425b43d4d2496c8c9c6cc3efd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const double &amp;value)</td></tr>
<tr class="separator:ae30b907425b43d4d2496c8c9c6cc3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def68d62af50ce897fae9b202357ced" id="r_a3def68d62af50ce897fae9b202357ced"><td class="memItemLeft" align="right" valign="top"><a id="a3def68d62af50ce897fae9b202357ced" name="a3def68d62af50ce897fae9b202357ced"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d9/d1d/classpl_color.htm">plColor</a> &amp;value)</td></tr>
<tr class="separator:a3def68d62af50ce897fae9b202357ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353cea191f37ff80153bf5da12833a33" id="r_a353cea191f37ff80153bf5da12833a33"><td class="memItemLeft" align="right" valign="top"><a id="a353cea191f37ff80153bf5da12833a33" name="a353cea191f37ff80153bf5da12833a33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/dd1/classpl_vec2_template.htm">plVec2</a> &amp;value)</td></tr>
<tr class="separator:a353cea191f37ff80153bf5da12833a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ee081e8372d3cca017c06babc444e" id="r_a583ee081e8372d3cca017c06babc444e"><td class="memItemLeft" align="right" valign="top"><a id="a583ee081e8372d3cca017c06babc444e" name="a583ee081e8372d3cca017c06babc444e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../df/d1f/classpl_vec3_template.htm">plVec3</a> &amp;value)</td></tr>
<tr class="separator:a583ee081e8372d3cca017c06babc444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784060518cb7014b62233504bba1fc59" id="r_a784060518cb7014b62233504bba1fc59"><td class="memItemLeft" align="right" valign="top"><a id="a784060518cb7014b62233504bba1fc59" name="a784060518cb7014b62233504bba1fc59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/d4b/classpl_vec4_template.htm">plVec4</a> &amp;value)</td></tr>
<tr class="separator:a784060518cb7014b62233504bba1fc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573ed9ebb7fc5bb65aa0a0d24923e677" id="r_a573ed9ebb7fc5bb65aa0a0d24923e677"><td class="memItemLeft" align="right" valign="top"><a id="a573ed9ebb7fc5bb65aa0a0d24923e677" name="a573ed9ebb7fc5bb65aa0a0d24923e677"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/dd1/classpl_vec2_template.htm">plVec2I32</a> &amp;value)</td></tr>
<tr class="separator:a573ed9ebb7fc5bb65aa0a0d24923e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9da1ff9cd62f2ce07717574a83a5d1" id="r_afa9da1ff9cd62f2ce07717574a83a5d1"><td class="memItemLeft" align="right" valign="top"><a id="afa9da1ff9cd62f2ce07717574a83a5d1" name="afa9da1ff9cd62f2ce07717574a83a5d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../df/d1f/classpl_vec3_template.htm">plVec3I32</a> &amp;value)</td></tr>
<tr class="separator:afa9da1ff9cd62f2ce07717574a83a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140aed88e6fb9e2826ef000f45645f93" id="r_a140aed88e6fb9e2826ef000f45645f93"><td class="memItemLeft" align="right" valign="top"><a id="a140aed88e6fb9e2826ef000f45645f93" name="a140aed88e6fb9e2826ef000f45645f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/d4b/classpl_vec4_template.htm">plVec4I32</a> &amp;value)</td></tr>
<tr class="separator:a140aed88e6fb9e2826ef000f45645f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b8c975b31aecc38aefa16453f4fbe8" id="r_ab3b8c975b31aecc38aefa16453f4fbe8"><td class="memItemLeft" align="right" valign="top"><a id="ab3b8c975b31aecc38aefa16453f4fbe8" name="ab3b8c975b31aecc38aefa16453f4fbe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/dd1/classpl_vec2_template.htm">plVec2U32</a> &amp;value)</td></tr>
<tr class="separator:ab3b8c975b31aecc38aefa16453f4fbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83edef78ca878e25500d778fb2f2e2c1" id="r_a83edef78ca878e25500d778fb2f2e2c1"><td class="memItemLeft" align="right" valign="top"><a id="a83edef78ca878e25500d778fb2f2e2c1" name="a83edef78ca878e25500d778fb2f2e2c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../df/d1f/classpl_vec3_template.htm">plVec3U32</a> &amp;value)</td></tr>
<tr class="separator:a83edef78ca878e25500d778fb2f2e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e431af513878c683720b4bd1e84f44e" id="r_a8e431af513878c683720b4bd1e84f44e"><td class="memItemLeft" align="right" valign="top"><a id="a8e431af513878c683720b4bd1e84f44e" name="a8e431af513878c683720b4bd1e84f44e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/d4b/classpl_vec4_template.htm">plVec4U32</a> &amp;value)</td></tr>
<tr class="separator:a8e431af513878c683720b4bd1e84f44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db8663bde86b4f8ddff503d46bae911" id="r_a6db8663bde86b4f8ddff503d46bae911"><td class="memItemLeft" align="right" valign="top"><a id="a6db8663bde86b4f8ddff503d46bae911" name="a6db8663bde86b4f8ddff503d46bae911"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d6/dad/classpl_quat_template.htm">plQuat</a> &amp;value)</td></tr>
<tr class="separator:a6db8663bde86b4f8ddff503d46bae911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad284b5940970284b115c6f429ef795e" id="r_aad284b5940970284b115c6f429ef795e"><td class="memItemLeft" align="right" valign="top"><a id="aad284b5940970284b115c6f429ef795e" name="aad284b5940970284b115c6f429ef795e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d5/d81/classpl_mat3_template.htm">plMat3</a> &amp;value)</td></tr>
<tr class="memdesc:aad284b5940970284b115c6f429ef795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors <br /></td></tr>
<tr class="separator:aad284b5940970284b115c6f429ef795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740d3555384a882043c315b67ed89549" id="r_a740d3555384a882043c315b67ed89549"><td class="memItemLeft" align="right" valign="top"><a id="a740d3555384a882043c315b67ed89549" name="a740d3555384a882043c315b67ed89549"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d4/dbd/classpl_mat4_template.htm">plMat4</a> &amp;value)</td></tr>
<tr class="separator:a740d3555384a882043c315b67ed89549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f685d2ab101429f26286b16c922d6b4" id="r_a4f685d2ab101429f26286b16c922d6b4"><td class="memItemLeft" align="right" valign="top"><a id="a4f685d2ab101429f26286b16c922d6b4" name="a4f685d2ab101429f26286b16c922d6b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d6/d78/classpl_transform_template.htm">plTransform</a> &amp;value)</td></tr>
<tr class="separator:a4f685d2ab101429f26286b16c922d6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd98747d83413e44c016f09674f9fef2" id="r_abd98747d83413e44c016f09674f9fef2"><td class="memItemLeft" align="right" valign="top"><a id="abd98747d83413e44c016f09674f9fef2" name="abd98747d83413e44c016f09674f9fef2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const char *value)</td></tr>
<tr class="separator:abd98747d83413e44c016f09674f9fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1ffdc62589fc5e2aa078a206fafcdd" id="r_a9b1ffdc62589fc5e2aa078a206fafcdd"><td class="memItemLeft" align="right" valign="top"><a id="a9b1ffdc62589fc5e2aa078a206fafcdd" name="a9b1ffdc62589fc5e2aa078a206fafcdd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d2/dea/structpl_hybrid_string.htm">plString</a> &amp;value)</td></tr>
<tr class="separator:a9b1ffdc62589fc5e2aa078a206fafcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f7b47813e58b236acb023eeda7a7a9" id="r_a46f7b47813e58b236acb023eeda7a7a9"><td class="memItemLeft" align="right" valign="top"><a id="a46f7b47813e58b236acb023eeda7a7a9" name="a46f7b47813e58b236acb023eeda7a7a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d2/dea/structpl_hybrid_string.htm">plUntrackedString</a> &amp;value)</td></tr>
<tr class="separator:a46f7b47813e58b236acb023eeda7a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c75d583d5a22c657262e582e2c0cac" id="r_a77c75d583d5a22c657262e582e2c0cac"><td class="memItemLeft" align="right" valign="top"><a id="a77c75d583d5a22c657262e582e2c0cac" name="a77c75d583d5a22c657262e582e2c0cac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d6/d79/classpl_string_view.htm">plStringView</a> &amp;value, bool bCopyString=true)</td></tr>
<tr class="separator:a77c75d583d5a22c657262e582e2c0cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d4d2f0d0f7647b371c6292d3ace07" id="r_a518d4d2f0d0f7647b371c6292d3ace07"><td class="memItemLeft" align="right" valign="top"><a id="a518d4d2f0d0f7647b371c6292d3ace07" name="a518d4d2f0d0f7647b371c6292d3ace07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d0/d4e/classpl_dynamic_array.htm">plDataBuffer</a> &amp;value)</td></tr>
<tr class="separator:a518d4d2f0d0f7647b371c6292d3ace07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827dfa1127af8bee9d523e061cea85e2" id="r_a827dfa1127af8bee9d523e061cea85e2"><td class="memItemLeft" align="right" valign="top"><a id="a827dfa1127af8bee9d523e061cea85e2" name="a827dfa1127af8bee9d523e061cea85e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d1/df6/structpl_time.htm">plTime</a> &amp;value)</td></tr>
<tr class="separator:a827dfa1127af8bee9d523e061cea85e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a10230e9b347bc6dbbe2e4db60b6a82" id="r_a7a10230e9b347bc6dbbe2e4db60b6a82"><td class="memItemLeft" align="right" valign="top"><a id="a7a10230e9b347bc6dbbe2e4db60b6a82" name="a7a10230e9b347bc6dbbe2e4db60b6a82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d6/d33/classpl_uuid.htm">plUuid</a> &amp;value)</td></tr>
<tr class="separator:a7a10230e9b347bc6dbbe2e4db60b6a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd34c6c77277370c27493d11bdb6181" id="r_a4cd34c6c77277370c27493d11bdb6181"><td class="memItemLeft" align="right" valign="top"><a id="a4cd34c6c77277370c27493d11bdb6181" name="a4cd34c6c77277370c27493d11bdb6181"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d4/dfd/classpl_angle.htm">plAngle</a> &amp;value)</td></tr>
<tr class="separator:a4cd34c6c77277370c27493d11bdb6181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f003894e85c8f956d51452f1877696" id="r_aa3f003894e85c8f956d51452f1877696"><td class="memItemLeft" align="right" valign="top"><a id="aa3f003894e85c8f956d51452f1877696" name="aa3f003894e85c8f956d51452f1877696"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../dd/dd8/classpl_color_gamma_u_b.htm">plColorGammaUB</a> &amp;value)</td></tr>
<tr class="separator:aa3f003894e85c8f956d51452f1877696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa26dc866fdc05efcdbff2e094dc7d7" id="r_a5aa26dc866fdc05efcdbff2e094dc7d7"><td class="memItemLeft" align="right" valign="top"><a id="a5aa26dc866fdc05efcdbff2e094dc7d7" name="a5aa26dc866fdc05efcdbff2e094dc7d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d0/dc8/classpl_hashed_string.htm">plHashedString</a> &amp;value)</td></tr>
<tr class="separator:a5aa26dc866fdc05efcdbff2e094dc7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55903a6aa581ffd9114960e24589f18" id="r_ab55903a6aa581ffd9114960e24589f18"><td class="memItemLeft" align="right" valign="top"><a id="ab55903a6aa581ffd9114960e24589f18" name="ab55903a6aa581ffd9114960e24589f18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d3/d33/classpl_temp_hashed_string.htm">plTempHashedString</a> &amp;value)</td></tr>
<tr class="separator:ab55903a6aa581ffd9114960e24589f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13450bd2546b9a4ecc1d304870a98e6" id="r_ac13450bd2546b9a4ecc1d304870a98e6"><td class="memItemLeft" align="right" valign="top"><a id="ac13450bd2546b9a4ecc1d304870a98e6" name="ac13450bd2546b9a4ecc1d304870a98e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d0/d4e/classpl_dynamic_array.htm">plVariantArray</a> &amp;value)</td></tr>
<tr class="separator:ac13450bd2546b9a4ecc1d304870a98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1af2f12a0002158d86661972aca13a" id="r_a6c1af2f12a0002158d86661972aca13a"><td class="memItemLeft" align="right" valign="top"><a id="a6c1af2f12a0002158d86661972aca13a" name="a6c1af2f12a0002158d86661972aca13a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../dd/d55/classpl_hash_table.htm">plVariantDictionary</a> &amp;value)</td></tr>
<tr class="separator:a6c1af2f12a0002158d86661972aca13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ee2cc867c51477db60a51a0f5ec92c" id="r_a48ee2cc867c51477db60a51a0f5ec92c"><td class="memItemLeft" align="right" valign="top"><a id="a48ee2cc867c51477db60a51a0f5ec92c" name="a48ee2cc867c51477db60a51a0f5ec92c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../d0/d9a/structpl_typed_pointer.htm">plTypedPointer</a> &amp;value)</td></tr>
<tr class="separator:a48ee2cc867c51477db60a51a0f5ec92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09912e4921dbcc69acb8b2f0c38212" id="r_a1d09912e4921dbcc69acb8b2f0c38212"><td class="memItemLeft" align="right" valign="top"><a id="a1d09912e4921dbcc69acb8b2f0c38212" name="a1d09912e4921dbcc69acb8b2f0c38212"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (const <a class="el" href="../../dd/d0f/structpl_typed_object.htm">plTypedObject</a> &amp;value)</td></tr>
<tr class="separator:a1d09912e4921dbcc69acb8b2f0c38212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6cf3a386cd957ce92d13312fc063c1" id="r_a2f6cf3a386cd957ce92d13312fc063c1"><td class="memTemplParams" colspan="2"><a id="a2f6cf3a386cd957ce92d13312fc063c1" name="a2f6cf3a386cd957ce92d13312fc063c1"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa1ac0cee5205d35054b26b26b8329504d">plVariantClass::CustomTypeCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2f6cf3a386cd957ce92d13312fc063c1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>plVariant</b> (const T &amp;value)</td></tr>
<tr class="separator:a2f6cf3a386cd957ce92d13312fc063c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8933b5c88ff08686cb968bcc41002f51" id="r_a8933b5c88ff08686cb968bcc41002f51"><td class="memTemplParams" colspan="2"><a id="a8933b5c88ff08686cb968bcc41002f51" name="a8933b5c88ff08686cb968bcc41002f51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8933b5c88ff08686cb968bcc41002f51"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>plVariant</b> (const T *value)</td></tr>
<tr class="separator:a8933b5c88ff08686cb968bcc41002f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae03a6de95af228208b4c0cf308e15a" id="r_a6ae03a6de95af228208b4c0cf308e15a"><td class="memItemLeft" align="right" valign="top"><a id="a6ae03a6de95af228208b4c0cf308e15a" name="a6ae03a6de95af228208b4c0cf308e15a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>plVariant</b> (void *value, const <a class="el" href="../../d8/dec/classpl_r_t_t_i.htm">plRTTI</a> *pType)</td></tr>
<tr class="memdesc:a6ae03a6de95af228208b4c0cf308e15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes to a TypedPointer of the given object and type. <br /></td></tr>
<tr class="separator:a6ae03a6de95af228208b4c0cf308e15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b03355328991c40e24a43128d429939" id="r_a0b03355328991c40e24a43128d429939"><td class="memItemLeft" align="right" valign="top"><a id="a0b03355328991c40e24a43128d429939" name="a0b03355328991c40e24a43128d429939"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTypedObject</b> (const void *value, const <a class="el" href="../../d8/dec/classpl_r_t_t_i.htm">plRTTI</a> *pType)</td></tr>
<tr class="memdesc:a0b03355328991c40e24a43128d429939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes to a TypedObject by cloning the given object and type. <br /></td></tr>
<tr class="separator:a0b03355328991c40e24a43128d429939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d4435c3467eb57bea7361d4f76abcd" id="r_a67d4435c3467eb57bea7361d4f76abcd"><td class="memItemLeft" align="right" valign="top"><a id="a67d4435c3467eb57bea7361d4f76abcd" name="a67d4435c3467eb57bea7361d4f76abcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MoveTypedObject</b> (void *value, const <a class="el" href="../../d8/dec/classpl_r_t_t_i.htm">plRTTI</a> *pType)</td></tr>
<tr class="memdesc:a67d4435c3467eb57bea7361d4f76abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes to a TypedObject by taking ownership of the given object and type. <br /></td></tr>
<tr class="separator:a67d4435c3467eb57bea7361d4f76abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a677a677c522a123cf7fe532ca11415" id="r_a6a677a677c522a123cf7fe532ca11415"><td class="memItemLeft" align="right" valign="top"><a id="a6a677a677c522a123cf7fe532ca11415" name="a6a677a677c522a123cf7fe532ca11415"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~plVariant</b> ()</td></tr>
<tr class="memdesc:a6a677a677c522a123cf7fe532ca11415"><td class="mdescLeft">&#160;</td><td class="mdescRight">If necessary, this will deallocate any heap memory that is not in use any more. <br /></td></tr>
<tr class="separator:a6a677a677c522a123cf7fe532ca11415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72ba9df066ce53e3f25213b67c9c1c5" id="r_ad72ba9df066ce53e3f25213b67c9c1c5"><td class="memItemLeft" align="right" valign="top"><a id="ad72ba9df066ce53e3f25213b67c9c1c5" name="ad72ba9df066ce53e3f25213b67c9c1c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;other)</td></tr>
<tr class="memdesc:ad72ba9df066ce53e3f25213b67c9c1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the <em>other</em> variant into this one. <br /></td></tr>
<tr class="separator:ad72ba9df066ce53e3f25213b67c9c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700d773fa1a8bc3f38798d85d336d30f" id="r_a700d773fa1a8bc3f38798d85d336d30f"><td class="memItemLeft" align="right" valign="top"><a id="a700d773fa1a8bc3f38798d85d336d30f" name="a700d773fa1a8bc3f38798d85d336d30f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a700d773fa1a8bc3f38798d85d336d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the data from the <em>other</em> variant into this one. <br /></td></tr>
<tr class="separator:a700d773fa1a8bc3f38798d85d336d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d392b81b5d1fc6393e7759a2e4b2f" id="r_a866d392b81b5d1fc6393e7759a2e4b2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a866d392b81b5d1fc6393e7759a2e4b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a866d392b81b5d1fc6393e7759a2e4b2f">operator=</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a866d392b81b5d1fc6393e7759a2e4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the type of <em>T</em> and stores <em>value</em>.  <br /></td></tr>
<tr class="separator:a866d392b81b5d1fc6393e7759a2e4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea37ecdc9fbe795d03902eee48736a5" id="r_a5ea37ecdc9fbe795d03902eee48736a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ea37ecdc9fbe795d03902eee48736a5">operator==</a> (const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;other) const</td></tr>
<tr class="memdesc:a5ea37ecdc9fbe795d03902eee48736a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will compare the value of this variant to that of <em>other</em>.  <br /></td></tr>
<tr class="separator:a5ea37ecdc9fbe795d03902eee48736a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f379db2c666caee9e7ab81ecaf58a2" id="r_ac4f379db2c666caee9e7ab81ecaf58a2"><td class="memItemLeft" align="right" valign="top"><a id="ac4f379db2c666caee9e7ab81ecaf58a2" name="ac4f379db2c666caee9e7ab81ecaf58a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PL_ADD_DEFAULT_OPERATOR_NOTEQUAL</b> (const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;)</td></tr>
<tr class="separator:ac4f379db2c666caee9e7ab81ecaf58a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3138de0cac816e24e0f0166e2b100" id="r_a66a3138de0cac816e24e0f0166e2b100"><td class="memTemplParams" colspan="2"><a id="a66a3138de0cac816e24e0f0166e2b100" name="a66a3138de0cac816e24e0f0166e2b100"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66a3138de0cac816e24e0f0166e2b100"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;other) const</td></tr>
<tr class="memdesc:a66a3138de0cac816e24e0f0166e2b100"><td class="mdescLeft">&#160;</td><td class="mdescRight">See non-templated operator==. <br /></td></tr>
<tr class="separator:a66a3138de0cac816e24e0f0166e2b100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49803212a366ca0df24bab01061a3ede" id="r_a49803212a366ca0df24bab01061a3ede"><td class="memItemLeft" align="right" valign="top"><a id="a49803212a366ca0df24bab01061a3ede" name="a49803212a366ca0df24bab01061a3ede"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsValid</b> () const</td></tr>
<tr class="memdesc:a49803212a366ca0df24bab01061a3ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this variant stores any other type than 'Invalid'. <br /></td></tr>
<tr class="separator:a49803212a366ca0df24bab01061a3ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ceef2497a809053fab2badda147752" id="r_a68ceef2497a809053fab2badda147752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ceef2497a809053fab2badda147752">IsNumber</a> () const</td></tr>
<tr class="memdesc:a68ceef2497a809053fab2badda147752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type is numerical type either integer or floating point.  <br /></td></tr>
<tr class="separator:a68ceef2497a809053fab2badda147752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01340a19137e7526f549a4f1cfd12f5" id="r_ac01340a19137e7526f549a4f1cfd12f5"><td class="memItemLeft" align="right" valign="top"><a id="ac01340a19137e7526f549a4f1cfd12f5" name="ac01340a19137e7526f549a4f1cfd12f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFloatingPoint</b> () const</td></tr>
<tr class="memdesc:ac01340a19137e7526f549a4f1cfd12f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type is floating point (float or double). <br /></td></tr>
<tr class="separator:ac01340a19137e7526f549a4f1cfd12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0c8da07b5e5869e3f4ac764fae7f8" id="r_aacf0c8da07b5e5869e3f4ac764fae7f8"><td class="memItemLeft" align="right" valign="top"><a id="aacf0c8da07b5e5869e3f4ac764fae7f8" name="aacf0c8da07b5e5869e3f4ac764fae7f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsString</b> () const</td></tr>
<tr class="memdesc:aacf0c8da07b5e5869e3f4ac764fae7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type is a string (plString or <a class="el" href="../../d6/d79/classpl_string_view.htm" title="plStringView represent a read-only sub-string of a larger string, as it can store a dedicated string ...">plStringView</a>). <br /></td></tr>
<tr class="separator:aacf0c8da07b5e5869e3f4ac764fae7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8fc2bb6b2e7a650c16b0c36901cd6f" id="r_a1e8fc2bb6b2e7a650c16b0c36901cd6f"><td class="memItemLeft" align="right" valign="top"><a id="a1e8fc2bb6b2e7a650c16b0c36901cd6f" name="a1e8fc2bb6b2e7a650c16b0c36901cd6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsHashedString</b> () const</td></tr>
<tr class="memdesc:a1e8fc2bb6b2e7a650c16b0c36901cd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type is a hashed string (<a class="el" href="../../d0/dc8/classpl_hashed_string.htm" title="This class is optimized to take nearly no memory (sizeof(void*)) and to allow very fast checks whethe...">plHashedString</a> or <a class="el" href="../../d3/d33/classpl_temp_hashed_string.htm" title="A class to use together with plHashedString for quick comparisons with temporary strings that need no...">plTempHashedString</a>). <br /></td></tr>
<tr class="separator:a1e8fc2bb6b2e7a650c16b0c36901cd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b" id="r_adcc086406e186bf6ae4824c506a2273b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcc086406e186bf6ae4824c506a2273b">IsA</a> () const</td></tr>
<tr class="memdesc:adcc086406e186bf6ae4824c506a2273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type is exactly the given type.  <br /></td></tr>
<tr class="separator:adcc086406e186bf6ae4824c506a2273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b" id="r_adcc086406e186bf6ae4824c506a2273b"><td class="memTemplParams" colspan="2"><a id="adcc086406e186bf6ae4824c506a2273b" name="adcc086406e186bf6ae4824c506a2273b"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2c23ee5735ac04416aafec179e7c1955">plVariantClass::PointerCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsA</b> () const</td></tr>
<tr class="separator:adcc086406e186bf6ae4824c506a2273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b" id="r_adcc086406e186bf6ae4824c506a2273b"><td class="memTemplParams" colspan="2"><a id="adcc086406e186bf6ae4824c506a2273b" name="adcc086406e186bf6ae4824c506a2273b"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa4d355493297fc18d2ba3094d4f42548b">plVariantClass::TypedObject</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsA</b> () const</td></tr>
<tr class="separator:adcc086406e186bf6ae4824c506a2273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b" id="r_adcc086406e186bf6ae4824c506a2273b"><td class="memTemplParams" colspan="2"><a id="adcc086406e186bf6ae4824c506a2273b" name="adcc086406e186bf6ae4824c506a2273b"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa1ac0cee5205d35054b26b26b8329504d">plVariantClass::CustomTypeCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adcc086406e186bf6ae4824c506a2273b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsA</b> () const</td></tr>
<tr class="separator:adcc086406e186bf6ae4824c506a2273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94599ada8024c478bbc3533c8776073" id="r_ac94599ada8024c478bbc3533c8776073"><td class="memItemLeft" align="right" valign="top"><a id="ac94599ada8024c478bbc3533c8776073" name="ac94599ada8024c478bbc3533c8776073"></a>
<a class="el" href="../../d6/d1e/structpl_variant_type.htm#a4d10a99c083abdf7283ab1f48565de12">Type::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetType</b> () const</td></tr>
<tr class="memdesc:ac94599ada8024c478bbc3533c8776073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact plVariant::Type value. <br /></td></tr>
<tr class="separator:ac94599ada8024c478bbc3533c8776073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3de72cc347c83a7d6048347693a0e8" id="r_adc3de72cc347c83a7d6048347693a0e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adc3de72cc347c83a7d6048347693a0e8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc3de72cc347c83a7d6048347693a0e8">Get</a> () const</td></tr>
<tr class="memdesc:adc3de72cc347c83a7d6048347693a0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variants value as the provided type.  <br /></td></tr>
<tr class="separator:adc3de72cc347c83a7d6048347693a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d4538d16d9d830e0848e2e12886f81" id="r_af3d4538d16d9d830e0848e2e12886f81"><td class="memTemplParams" colspan="2"><a id="af3d4538d16d9d830e0848e2e12886f81" name="af3d4538d16d9d830e0848e2e12886f81"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2c23ee5735ac04416aafec179e7c1955">plVariantClass::PointerCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af3d4538d16d9d830e0848e2e12886f81"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:af3d4538d16d9d830e0848e2e12886f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2780070d963ccb11b4fd25ecfa7e07" id="r_aca2780070d963ccb11b4fd25ecfa7e07"><td class="memTemplParams" colspan="2"><a id="aca2780070d963ccb11b4fd25ecfa7e07" name="aca2780070d963ccb11b4fd25ecfa7e07"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa4d355493297fc18d2ba3094d4f42548b">plVariantClass::TypedObject</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aca2780070d963ccb11b4fd25ecfa7e07"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:aca2780070d963ccb11b4fd25ecfa7e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3de72cc347c83a7d6048347693a0e8" id="r_adc3de72cc347c83a7d6048347693a0e8"><td class="memTemplParams" colspan="2"><a id="adc3de72cc347c83a7d6048347693a0e8" name="adc3de72cc347c83a7d6048347693a0e8"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa1ac0cee5205d35054b26b26b8329504d">plVariantClass::CustomTypeCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adc3de72cc347c83a7d6048347693a0e8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:adc3de72cc347c83a7d6048347693a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc607b0b0c9a866911949563dfff7a8" id="r_a8bc607b0b0c9a866911949563dfff7a8"><td class="memItemLeft" align="right" valign="top"><a id="a8bc607b0b0c9a866911949563dfff7a8" name="a8bc607b0b0c9a866911949563dfff7a8"></a>
<a class="el" href="../../d0/d9a/structpl_typed_pointer.htm">plTypedPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetWriteAccess</b> ()</td></tr>
<tr class="memdesc:a8bc607b0b0c9a866911949563dfff7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an writable <a class="el" href="../../d0/d9a/structpl_typed_pointer.htm" title="A typed raw pointer.">plTypedPointer</a> to the internal data. If the data is currently shared a clone will be made to ensure we hold the only reference. <br /></td></tr>
<tr class="separator:a8bc607b0b0c9a866911949563dfff7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdb33d59f3c4ddec80dd2d78a4888a8" id="r_a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memTemplParams" colspan="2"><a id="a2cdb33d59f3c4ddec80dd2d78a4888a8" name="a2cdb33d59f3c4ddec80dd2d78a4888a8"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWritable</b> ()</td></tr>
<tr class="separator:a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f3e1ed98cd10a5af10f4e02d8493e" id="r_a4e1f3e1ed98cd10a5af10f4e02d8493e"><td class="memTemplParams" colspan="2"><a id="a4e1f3e1ed98cd10a5af10f4e02d8493e" name="a4e1f3e1ed98cd10a5af10f4e02d8493e"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2c23ee5735ac04416aafec179e7c1955">plVariantClass::PointerCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4e1f3e1ed98cd10a5af10f4e02d8493e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWritable</b> ()</td></tr>
<tr class="separator:a4e1f3e1ed98cd10a5af10f4e02d8493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdb33d59f3c4ddec80dd2d78a4888a8" id="r_a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memTemplParams" colspan="2"><a id="a2cdb33d59f3c4ddec80dd2d78a4888a8" name="a2cdb33d59f3c4ddec80dd2d78a4888a8"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa1ac0cee5205d35054b26b26b8329504d">plVariantClass::CustomTypeCast</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWritable</b> ()</td></tr>
<tr class="separator:a2cdb33d59f3c4ddec80dd2d78a4888a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714146850f08f502480c438685f9fbfa" id="r_a714146850f08f502480c438685f9fbfa"><td class="memItemLeft" align="right" valign="top"><a id="a714146850f08f502480c438685f9fbfa" name="a714146850f08f502480c438685f9fbfa"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>GetData</b> () const</td></tr>
<tr class="memdesc:a714146850f08f502480c438685f9fbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const void* to the internal data. For TypedPointer and TypedObject this will return a pointer to the target object. <br /></td></tr>
<tr class="separator:a714146850f08f502480c438685f9fbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb46746378594373b74130ba7f3255c" id="r_a0fb46746378594373b74130ba7f3255c"><td class="memItemLeft" align="right" valign="top"><a id="a0fb46746378594373b74130ba7f3255c" name="a0fb46746378594373b74130ba7f3255c"></a>
const <a class="el" href="../../d8/dec/classpl_r_t_t_i.htm">plRTTI</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetReflectedType</b> () const</td></tr>
<tr class="memdesc:a0fb46746378594373b74130ba7f3255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../d8/dec/classpl_r_t_t_i.htm" title="This class holds information about reflected types. Each instance represents one type that is known t...">plRTTI</a> type of the held value. For TypedPointer and TypedObject this will return the type of the target object. <br /></td></tr>
<tr class="separator:a0fb46746378594373b74130ba7f3255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d96408f2d559ac538461e54bdfa863" id="r_a04d96408f2d559ac538461e54bdfa863"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d96408f2d559ac538461e54bdfa863">operator[]</a> (plUInt32 uiIndex) const</td></tr>
<tr class="memdesc:a04d96408f2d559ac538461e54bdfa863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sub value at iIndex. This could be an element in an array or a member property inside a reflected type.  <br /></td></tr>
<tr class="separator:a04d96408f2d559ac538461e54bdfa863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca797a59228c08cfc339b26031db63" id="r_a4fca797a59228c08cfc339b26031db63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fca797a59228c08cfc339b26031db63">operator[]</a> (<a class="el" href="../../d1/d90/structpl_variant_1_1_string_wrapper.htm">StringWrapper</a> key) const</td></tr>
<tr class="memdesc:a4fca797a59228c08cfc339b26031db63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sub value with szKey. This could be a value in a dictionary or a member property inside a reflected type.  <br /></td></tr>
<tr class="separator:a4fca797a59228c08cfc339b26031db63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee6294d59c2b90e36873fa7af1c3335" id="r_acee6294d59c2b90e36873fa7af1c3335"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acee6294d59c2b90e36873fa7af1c3335"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acee6294d59c2b90e36873fa7af1c3335">CanConvertTo</a> () const</td></tr>
<tr class="memdesc:acee6294d59c2b90e36873fa7af1c3335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the stored type can generally be converted to the desired type.  <br /></td></tr>
<tr class="separator:acee6294d59c2b90e36873fa7af1c3335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bfa578f49e2628b84d756456d63c1f" id="r_ab3bfa578f49e2628b84d756456d63c1f"><td class="memItemLeft" align="right" valign="top"><a id="ab3bfa578f49e2628b84d756456d63c1f" name="ab3bfa578f49e2628b84d756456d63c1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CanConvertTo</b> (<a class="el" href="../../d6/d1e/structpl_variant_type.htm#a4d10a99c083abdf7283ab1f48565de12">Type::Enum</a> type) const</td></tr>
<tr class="memdesc:ab3bfa578f49e2628b84d756456d63c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the templated CanConvertTo function. <br /></td></tr>
<tr class="separator:ab3bfa578f49e2628b84d756456d63c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b157bdd88b07b364d78b25f850d05c" id="r_a86b157bdd88b07b364d78b25f850d05c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86b157bdd88b07b364d78b25f850d05c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86b157bdd88b07b364d78b25f850d05c">ConvertTo</a> (<a class="el" href="../../da/dce/structpl_result.htm">plResult</a> *out_pConversionStatus=nullptr) const</td></tr>
<tr class="memdesc:a86b157bdd88b07b364d78b25f850d05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to convert the stored value to the given type. The optional status parameter can be used to check whether the conversion succeeded.  <br /></td></tr>
<tr class="separator:a86b157bdd88b07b364d78b25f850d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122602202eb64f595fa3873895049f3e" id="r_a122602202eb64f595fa3873895049f3e"><td class="memItemLeft" align="right" valign="top"><a id="a122602202eb64f595fa3873895049f3e" name="a122602202eb64f595fa3873895049f3e"></a>
<a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertTo</b> (<a class="el" href="../../d6/d1e/structpl_variant_type.htm#a4d10a99c083abdf7283ab1f48565de12">Type::Enum</a> type, <a class="el" href="../../da/dce/structpl_result.htm">plResult</a> *out_pConversionStatus=nullptr) const</td></tr>
<tr class="memdesc:a122602202eb64f595fa3873895049f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the templated function. <br /></td></tr>
<tr class="separator:a122602202eb64f595fa3873895049f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa267cffdfb0a021d71fe578a2d34f7fd" id="r_aa267cffdfb0a021d71fe578a2d34f7fd"><td class="memItemLeft" align="right" valign="top"><a id="aa267cffdfb0a021d71fe578a2d34f7fd" name="aa267cffdfb0a021d71fe578a2d34f7fd"></a>
plUInt64&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeHash</b> (plUInt64 uiSeed=0) const</td></tr>
<tr class="memdesc:aa267cffdfb0a021d71fe578a2d34f7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of the stored data. Returns uiSeed (unchanged) for an invalid Variant. <br /></td></tr>
<tr class="separator:aa267cffdfb0a021d71fe578a2d34f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26e2df0d0b089210647b7b2277a13f3" id="r_af26e2df0d0b089210647b7b2277a13f3"><td class="memTemplParams" colspan="2"><a id="af26e2df0d0b089210647b7b2277a13f3" name="af26e2df0d0b089210647b7b2277a13f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af26e2df0d0b089210647b7b2277a13f3"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitShared</b> (const T &amp;value)</td></tr>
<tr class="separator:af26e2df0d0b089210647b7b2277a13f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15096e23b08b14cdadbf49cfc22409b" id="r_ae15096e23b08b14cdadbf49cfc22409b"><td class="memTemplParams" colspan="2"><a id="ae15096e23b08b14cdadbf49cfc22409b" name="ae15096e23b08b14cdadbf49cfc22409b"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa1ac0cee5205d35054b26b26b8329504d">plVariantClass::CustomTypeCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:ae15096e23b08b14cdadbf49cfc22409b"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE&#160;</td><td class="memTemplItemRight" valign="bottom"><b>plVariant</b> (const T &amp;value)</td></tr>
<tr class="separator:ae15096e23b08b14cdadbf49cfc22409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7257083baffdf8cb99913af9aacfc803" id="r_a7257083baffdf8cb99913af9aacfc803"><td class="memTemplParams" colspan="2"><a id="a7257083baffdf8cb99913af9aacfc803" name="a7257083baffdf8cb99913af9aacfc803"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7257083baffdf8cb99913af9aacfc803"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE&#160;</td><td class="memTemplItemRight" valign="bottom"><b>plVariant</b> (const T *value)</td></tr>
<tr class="separator:a7257083baffdf8cb99913af9aacfc803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d869ebfa0def7b05c184e5c0015f72a" id="r_a8d869ebfa0def7b05c184e5c0015f72a"><td class="memTemplParams" colspan="2"><a id="a8d869ebfa0def7b05c184e5c0015f72a" name="a8d869ebfa0def7b05c184e5c0015f72a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d869ebfa0def7b05c184e5c0015f72a"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const T &amp;value)</td></tr>
<tr class="separator:a8d869ebfa0def7b05c184e5c0015f72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713a70e5a42315432669a2368e51c03f" id="r_a713a70e5a42315432669a2368e51c03f"><td class="memTemplParams" colspan="2"><a id="a713a70e5a42315432669a2368e51c03f" name="a713a70e5a42315432669a2368e51c03f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a713a70e5a42315432669a2368e51c03f"><td class="memTemplItemLeft" align="right" valign="top">PL_FORCE_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;other) const</td></tr>
<tr class="separator:a713a70e5a42315432669a2368e51c03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ec473c2943a16271d5ee745b05307b" id="r_ad5ec473c2943a16271d5ee745b05307b"><td class="memTemplParams" colspan="2"><a id="ad5ec473c2943a16271d5ee745b05307b" name="ad5ec473c2943a16271d5ee745b05307b"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:ad5ec473c2943a16271d5ee745b05307b"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsA</b> () const</td></tr>
<tr class="separator:ad5ec473c2943a16271d5ee745b05307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a70e2f555404e7389e6bbd7080adc" id="r_a043a70e2f555404e7389e6bbd7080adc"><td class="memTemplParams" colspan="2"><a id="a043a70e2f555404e7389e6bbd7080adc" name="a043a70e2f555404e7389e6bbd7080adc"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:a043a70e2f555404e7389e6bbd7080adc"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:a043a70e2f555404e7389e6bbd7080adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285afac8bf7232f5fb754606bddc9eb" id="r_af285afac8bf7232f5fb754606bddc9eb"><td class="memTemplParams" colspan="2"><a id="af285afac8bf7232f5fb754606bddc9eb" name="af285afac8bf7232f5fb754606bddc9eb"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2c23ee5735ac04416aafec179e7c1955">plVariantClass::PointerCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:af285afac8bf7232f5fb754606bddc9eb"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:af285afac8bf7232f5fb754606bddc9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1c5fa1e78350d77cd386fafb8ba7c7" id="r_acd1c5fa1e78350d77cd386fafb8ba7c7"><td class="memTemplParams" colspan="2"><a id="acd1c5fa1e78350d77cd386fafb8ba7c7" name="acd1c5fa1e78350d77cd386fafb8ba7c7"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa4d355493297fc18d2ba3094d4f42548b">plVariantClass::TypedObject</a>, int &gt; &gt; </td></tr>
<tr class="memitem:acd1c5fa1e78350d77cd386fafb8ba7c7"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE const T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> () const</td></tr>
<tr class="separator:acd1c5fa1e78350d77cd386fafb8ba7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd8d82c01284dd53e85d6a4238442e2" id="r_aacd8d82c01284dd53e85d6a4238442e2"><td class="memTemplParams" colspan="2"><a id="aacd8d82c01284dd53e85d6a4238442e2" name="aacd8d82c01284dd53e85d6a4238442e2"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:aacd8d82c01284dd53e85d6a4238442e2"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWritable</b> ()</td></tr>
<tr class="separator:aacd8d82c01284dd53e85d6a4238442e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75285e6c129ea88aa177e4ce9ad716ad" id="r_a75285e6c129ea88aa177e4ce9ad716ad"><td class="memTemplParams" colspan="2"><a id="a75285e6c129ea88aa177e4ce9ad716ad" name="a75285e6c129ea88aa177e4ce9ad716ad"></a>
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2c23ee5735ac04416aafec179e7c1955">plVariantClass::PointerCast</a>, int &gt; &gt; </td></tr>
<tr class="memitem:a75285e6c129ea88aa177e4ce9ad716ad"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWritable</b> ()</td></tr>
<tr class="separator:a75285e6c129ea88aa177e4ce9ad716ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da81fa32922bba9080dd3ff6a4d465" id="r_ae2da81fa32922bba9080dd3ff6a4d465"><td class="memTemplParams" colspan="2"><a id="ae2da81fa32922bba9080dd3ff6a4d465" name="ae2da81fa32922bba9080dd3ff6a4d465"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2da81fa32922bba9080dd3ff6a4d465"><td class="memTemplItemLeft" align="right" valign="top">PL_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CanConvertTo</b> () const</td></tr>
<tr class="separator:ae2da81fa32922bba9080dd3ff6a4d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45303b799748b74e0e87c28f1ee9631e" id="r_a45303b799748b74e0e87c28f1ee9631e"><td class="memTemplParams" colspan="2"><a id="a45303b799748b74e0e87c28f1ee9631e" name="a45303b799748b74e0e87c28f1ee9631e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45303b799748b74e0e87c28f1ee9631e"><td class="memTemplItemLeft" align="right" valign="top">PL_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitInplace</b> (const T &amp;value)</td></tr>
<tr class="memdesc:a45303b799748b74e0e87c28f1ee9631e"><td class="mdescLeft">&#160;</td><td class="mdescRight">private methods <br /></td></tr>
<tr class="separator:a45303b799748b74e0e87c28f1ee9631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af622d2e1bf0f7d04da9dd76eb593ceba" id="r_af622d2e1bf0f7d04da9dd76eb593ceba"><td class="memTemplParams" colspan="2"><a id="af622d2e1bf0f7d04da9dd76eb593ceba" name="af622d2e1bf0f7d04da9dd76eb593ceba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af622d2e1bf0f7d04da9dd76eb593ceba"><td class="memTemplItemLeft" align="right" valign="top">PL_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitTypedObject</b> (const T &amp;value, <a class="el" href="../../de/d69/structpl_trait_int.htm">plTraitInt</a>&lt; 0 &gt;)</td></tr>
<tr class="separator:af622d2e1bf0f7d04da9dd76eb593ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16376556d54011eecb124921c9bb7a3" id="r_ac16376556d54011eecb124921c9bb7a3"><td class="memTemplParams" colspan="2"><a id="ac16376556d54011eecb124921c9bb7a3" name="ac16376556d54011eecb124921c9bb7a3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac16376556d54011eecb124921c9bb7a3"><td class="memTemplItemLeft" align="right" valign="top">PL_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitTypedObject</b> (const T &amp;value, <a class="el" href="../../de/d69/structpl_trait_int.htm">plTraitInt</a>&lt; 1 &gt;)</td></tr>
<tr class="separator:ac16376556d54011eecb124921c9bb7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab1336e12e4e9fb278991d2fe0e8c469a" id="r_ab1336e12e4e9fb278991d2fe0e8c469a"><td class="memTemplParams" colspan="2">template&lt;typename Functor , class... Args&gt; </td></tr>
<tr class="memitem:ab1336e12e4e9fb278991d2fe0e8c469a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1336e12e4e9fb278991d2fe0e8c469a">DispatchTo</a> (Functor &amp;ref_functor, <a class="el" href="../../d6/d1e/structpl_variant_type.htm#a4d10a99c083abdf7283ab1f48565de12">Type::Enum</a> type, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab1336e12e4e9fb278991d2fe0e8c469a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will call the overloaded operator() (function call operator) of the provided functor.  <br /></td></tr>
<tr class="separator:ab1336e12e4e9fb278991d2fe0e8c469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4a53b7052be4fa0f7a08c04931796a07" id="r_a4a53b7052be4fa0f7a08c04931796a07"><td class="memItemLeft" align="right" valign="top"><a id="a4a53b7052be4fa0f7a08c04931796a07" name="a4a53b7052be4fa0f7a08c04931796a07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>plVariantHelper</b></td></tr>
<tr class="separator:a4a53b7052be4fa0f7a08c04931796a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c30e09ce4827ae59948f694bbc95495" id="r_a4c30e09ce4827ae59948f694bbc95495"><td class="memItemLeft" align="right" valign="top"><a id="a4c30e09ce4827ae59948f694bbc95495" name="a4c30e09ce4827ae59948f694bbc95495"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>CompareFunc</b></td></tr>
<tr class="separator:a4c30e09ce4827ae59948f694bbc95495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fb9dde7601af1db3639dc733818fff" id="r_aa3fb9dde7601af1db3639dc733818fff"><td class="memItemLeft" align="right" valign="top"><a id="aa3fb9dde7601af1db3639dc733818fff" name="aa3fb9dde7601af1db3639dc733818fff"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>GetTypeFromVariantFunc</b></td></tr>
<tr class="separator:aa3fb9dde7601af1db3639dc733818fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../da/d4c/classpl_variant.htm" title="plVariant is a class that can store different types of variables, which is useful in situations where...">plVariant</a> is a class that can store different types of variables, which is useful in situations where it is not clear up front, which type of data will be passed around. </p>
<p>The variant supports a fixed list of types that it can store (</p><dl class="section see"><dt>See also</dt><dd>plVariant::Type). All types of 16 bytes or less in size can be stored without requiring a heap allocation. For larger types memory is allocated on the heap. In general variants should be used for code that needs to be flexible. Although <a class="el" href="../../da/d4c/classpl_variant.htm" title="plVariant is a class that can store different types of variables, which is useful in situations where...">plVariant</a> is implemented very efficiently, it should be avoided to use <a class="el" href="../../da/d4c/classpl_variant.htm" title="plVariant is a class that can store different types of variables, which is useful in situations where...">plVariant</a> in code that needs to be fast. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada90bbbda7a21033b0e91f7b3492c555" name="ada90bbbda7a21033b0e91f7b3492c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada90bbbda7a21033b0e91f7b3492c555">&#9670;&#160;</a></span>plVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PL_ALWAYS_INLINE plVariant::plVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data from the other variant. </p>
<dl class="section note"><dt>Note</dt><dd>If the data of the variant needed to be allocated on the heap, it will be shared among variants. Thus, once you have stored such a type inside a variant, you can copy it to other variants, without introducing additional memory allocations. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acee6294d59c2b90e36873fa7af1c3335" name="acee6294d59c2b90e36873fa7af1c3335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee6294d59c2b90e36873fa7af1c3335">&#9670;&#160;</a></span>CanConvertTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool plVariant::CanConvertTo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the stored type can generally be converted to the desired type. </p>
<p>This function will return true for all number conversions, as float / double / int / etc. can generally be converted into each other. It will also return true for all conversion from string to number types, and from all 'simple' types (not array or dictionary) to string.</p>
<dl class="section note"><dt>Note</dt><dd>This function only returns whether a conversion between the stored TYPE and the desired TYPE is generally possible. It does NOT return whether the stored VALUE is indeed convertible to the desired type. For example, a string is generally convertible to float, if it stores a string representation of a float value. If, however, it stores anything else, the conversion can still fail.</dd></dl>
<p>The only way to figure out whether the stored data can be converted to some type, is to actually convert it, using <a class="el" href="#a86b157bdd88b07b364d78b25f850d05c" title="Tries to convert the stored value to the given type. The optional status parameter can be used to che...">ConvertTo()</a>, and then to check the conversion status. </p>

</div>
</div>
<a id="a86b157bdd88b07b364d78b25f850d05c" name="a86b157bdd88b07b364d78b25f850d05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b157bdd88b07b364d78b25f850d05c">&#9670;&#160;</a></span>ConvertTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T plVariant::ConvertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dce/structpl_result.htm">plResult</a> *</td>          <td class="paramname"><span class="paramname"><em>out_pConversionStatus</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to convert the stored value to the given type. The optional status parameter can be used to check whether the conversion succeeded. </p>
<p>When <a class="el" href="#acee6294d59c2b90e36873fa7af1c3335" title="Returns whether the stored type can generally be converted to the desired type.">CanConvertTo()</a> returns false, <a class="el" href="#a86b157bdd88b07b364d78b25f850d05c" title="Tries to convert the stored value to the given type. The optional status parameter can be used to che...">ConvertTo()</a> will also always fail. However, when <a class="el" href="#acee6294d59c2b90e36873fa7af1c3335" title="Returns whether the stored type can generally be converted to the desired type.">CanConvertTo()</a> returns true, this is no guarantee that <a class="el" href="#a86b157bdd88b07b364d78b25f850d05c" title="Tries to convert the stored value to the given type. The optional status parameter can be used to che...">ConvertTo()</a> will succeed. Conversion between numbers and to strings will generally succeed. However, converting from a string to another type can fail or succeed, depending on the exact string value. </p>

</div>
</div>
<a id="ab1336e12e4e9fb278991d2fe0e8c469a" name="ab1336e12e4e9fb278991d2fe0e8c469a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1336e12e4e9fb278991d2fe0e8c469a">&#9670;&#160;</a></span>DispatchTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto plVariant::DispatchTo </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;</td>          <td class="paramname"><span class="paramname"><em>ref_functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d1e/structpl_variant_type.htm#a4d10a99c083abdf7283ab1f48565de12">Type::Enum</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will call the overloaded operator() (function call operator) of the provided functor. </p>
<p>This allows to implement a functor that overloads operator() for different types and then call the proper version of that operator, depending on the provided runtime type. Note that the proper overload of operator() is selected by providing a dummy type, but it will contain no useful value. Instead, store the other necessary data inside the functor object, before calling this function. For example, store a pointer to a variant inside the functor object and then call DispatchTo to execute the function that will handle the given type of the variant. </p>

</div>
</div>
<a id="adc3de72cc347c83a7d6048347693a0e8" name="adc3de72cc347c83a7d6048347693a0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3de72cc347c83a7d6048347693a0e8">&#9670;&#160;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; plVariant::Get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variants value as the provided type. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not do ANY type of conversion from the stored type to the given type. Not even integer conversions! If the types don't match, this function will assert! So be careful to use this function only when you know exactly that the stored type matches the expected type.</dd></dl>
<p>Prefer to use <a class="el" href="#a86b157bdd88b07b364d78b25f850d05c" title="Tries to convert the stored value to the given type. The optional status parameter can be used to che...">ConvertTo()</a> when you can instead. </p>

</div>
</div>
<a id="adcc086406e186bf6ae4824c506a2273b" name="adcc086406e186bf6ae4824c506a2273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc086406e186bf6ae4824c506a2273b">&#9670;&#160;</a></span>IsA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if_t&lt; <a class="el" href="../../d6/d03/structpl_variant_type_deduction.htm">plVariantTypeDeduction</a>&lt; T &gt;::classification==<a class="el" href="../../d0/dc0/structpl_variant_class.htm#a6e7c301d9b38061519dd57b0889491baa2d379cb8c2e1d77c442d26bbd6571f78">plVariantClass::DirectCast</a>, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool plVariant::IsA </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the stored type is exactly the given type. </p>
<dl class="section note"><dt>Note</dt><dd>This explicitly also differentiates between the different integer types. So when the variant stores an Int32, <a class="el" href="#adcc086406e186bf6ae4824c506a2273b" title="Returns whether the stored type is exactly the given type.">IsA&lt;Int64&gt;()</a> will return false, even though the types could be converted. </dd></dl>

</div>
</div>
<a id="a68ceef2497a809053fab2badda147752" name="a68ceef2497a809053fab2badda147752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ceef2497a809053fab2badda147752">&#9670;&#160;</a></span>IsNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PL_ALWAYS_INLINE bool plVariant::IsNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the stored type is numerical type either integer or floating point. </p>
<p>Bool counts as number. </p>

</div>
</div>
<a id="a866d392b81b5d1fc6393e7759a2e4b2f" name="a866d392b81b5d1fc6393e7759a2e4b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d392b81b5d1fc6393e7759a2e4b2f">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void plVariant::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduces the type of <em>T</em> and stores <em>value</em>. </p>
<p>If the type to be stored in the variant is not supported, a compile time error will occur. </p>

</div>
</div>
<a id="a5ea37ecdc9fbe795d03902eee48736a5" name="a5ea37ecdc9fbe795d03902eee48736a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea37ecdc9fbe795d03902eee48736a5">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool plVariant::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will compare the value of this variant to that of <em>other</em>. </p>
<p>public methods</p>
<p>If both variants store 'numbers' (float, double, int types) the comparison will work, even if the types are not identical.</p>
<dl class="section note"><dt>Note</dt><dd>If the two types are not numbers and not equal, an assert will occur. So be careful to only compare variants that can either both be converted to double (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acee6294d59c2b90e36873fa7af1c3335" title="Returns whether the stored type can generally be converted to the desired type.">CanConvertTo()</a>) or whose types are equal. </dd></dl>

</div>
</div>
<a id="a04d96408f2d559ac538461e54bdfa863" name="a04d96408f2d559ac538461e54bdfa863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d96408f2d559ac538461e54bdfa863">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> plVariant::operator[] </td>
          <td>(</td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sub value at iIndex. This could be an element in an array or a member property inside a reflected type. </p>
<p>Out of bounds access is handled gracefully and will return an invalid variant. </p>

</div>
</div>
<a id="a4fca797a59228c08cfc339b26031db63" name="a4fca797a59228c08cfc339b26031db63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca797a59228c08cfc339b26031db63">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a> plVariant::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d90/structpl_variant_1_1_string_wrapper.htm">StringWrapper</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sub value with szKey. This could be a value in a dictionary or a member property inside a reflected type. </p>
<p>This function will return an invalid variant if no corresponding sub value is found. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Engine/Foundation/Types/<a class="el" href="../../d2/d19/_variant_8h_source.htm">Variant.h</a></li>
<li>Code/Engine/Foundation/Types/Implementation/<b>Variant.cpp</b></li>
<li>Code/Engine/Foundation/Types/Implementation/<a class="el" href="../../d5/d0a/_variant__inl_8h_source.htm">Variant_inl.h</a></li>
<li>Code/Engine/Foundation/Types/Implementation/<a class="el" href="../../d0/dc7/_variant_helper__inl_8h_source.htm">VariantHelper_inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../da/d4c/classpl_variant.htm">plVariant</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
