<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Plasma Engine: plTaskSystem Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../pl-logo-64.png"/></td>
  <td id="projectalign">
   <div id="projectname">Plasma Engine<span id="projectnumber">&#160;2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.htm');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.htm','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/dc1/classpl_task_system.htm','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="../../d0/d5a/classpl_task_system-members.htm">List of all members</a>  </div>
  <div class="headertitle"><div class="title">plTaskSystem Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This system allows to automatically distribute tasks onto a number of worker threads.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/d50/_task_system_8h_source.htm">TaskSystem.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dab/structpl_task_system_1_1_task_data.htm">TaskData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utilities</div></td></tr>
<tr class="memitem:ad4e414453f04476b46700a700525ac25" id="r_ad4e414453f04476b46700a700525ac25"><td class="memItemLeft" align="right" valign="top"><a id="ad4e414453f04476b46700a700525ac25" name="ad4e414453f04476b46700a700525ac25"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteStateSnapshotToDGML</b> (<a class="el" href="../../d0/de4/classpl_d_g_m_l_graph.htm">plDGMLGraph</a> &amp;ref_graph)</td></tr>
<tr class="memdesc:ad4e414453f04476b46700a700525ac25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the internal state of the <a class="el" href="../../d5/dc1/classpl_task_system.htm" title="This system allows to automatically distribute tasks onto a number of worker threads.">plTaskSystem</a> as a DGML graph. <br /></td></tr>
<tr class="separator:ad4e414453f04476b46700a700525ac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd50c60654f9448503f09dcc7fd54258" id="r_acd50c60654f9448503f09dcc7fd54258"><td class="memItemLeft" align="right" valign="top"><a id="acd50c60654f9448503f09dcc7fd54258" name="acd50c60654f9448503f09dcc7fd54258"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteStateSnapshotToFile</b> (const char *szPath=nullptr)</td></tr>
<tr class="memdesc:acd50c60654f9448503f09dcc7fd54258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to write the task graph snapshot to a file. If no path is given, the file is written to ":appdata/TaskGraphs/__date__.dgml". <br /></td></tr>
<tr class="separator:acd50c60654f9448503f09dcc7fd54258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Thread Management</h2></td></tr>
<tr class="memitem:aecce50afa3e08a72f1bae0baf31f243f" id="r_aecce50afa3e08a72f1bae0baf31f243f"><td class="memItemLeft" align="right" valign="top"><a id="aecce50afa3e08a72f1bae0baf31f243f" name="aecce50afa3e08a72f1bae0baf31f243f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>plTaskWorkerThread</b></td></tr>
<tr class="separator:aecce50afa3e08a72f1bae0baf31f243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b28000c195e686f3d644ac72f473b" id="r_a8a9b28000c195e686f3d644ac72f473b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9b28000c195e686f3d644ac72f473b">SetWorkerThreadCount</a> (plInt32 iShortTasks=-1, plInt32 iLongTasks=-1)</td></tr>
<tr class="memdesc:a8a9b28000c195e686f3d644ac72f473b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to use for the different task categories.  <br /></td></tr>
<tr class="separator:a8a9b28000c195e686f3d644ac72f473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2c461748dc990ccb61ddf23c5f3eb" id="r_a5dd2c461748dc990ccb61ddf23c5f3eb"><td class="memItemLeft" align="right" valign="top"><a id="a5dd2c461748dc990ccb61ddf23c5f3eb" name="a5dd2c461748dc990ccb61ddf23c5f3eb"></a>
static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><b>GetWorkerThreadCount</b> (<a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a> type)</td></tr>
<tr class="memdesc:a5dd2c461748dc990ccb61ddf23c5f3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of threads that should work on the given type of task at the same time. <br /></td></tr>
<tr class="separator:a5dd2c461748dc990ccb61ddf23c5f3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40572acab2a634ddb0bb1a7a22c8a7d8" id="r_a40572acab2a634ddb0bb1a7a22c8a7d8"><td class="memItemLeft" align="right" valign="top">static plUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40572acab2a634ddb0bb1a7a22c8a7d8">GetNumAllocatedWorkerThreads</a> (<a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a> type)</td></tr>
<tr class="memdesc:a40572acab2a634ddb0bb1a7a22c8a7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads that have been allocated to potentially work on the given type of task.  <br /></td></tr>
<tr class="separator:a40572acab2a634ddb0bb1a7a22c8a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911f176a8e636a99b13defe9e29e5331" id="r_a911f176a8e636a99b13defe9e29e5331"><td class="memItemLeft" align="right" valign="top"><a id="a911f176a8e636a99b13defe9e29e5331" name="a911f176a8e636a99b13defe9e29e5331"></a>
static <a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentThreadWorkerType</b> ()</td></tr>
<tr class="memdesc:a911f176a8e636a99b13defe9e29e5331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (thread local) type of tasks that would be executed on this thread. <br /></td></tr>
<tr class="separator:a911f176a8e636a99b13defe9e29e5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef339c4486c8dcd6258e2ebc412988ea" id="r_aef339c4486c8dcd6258e2ebc412988ea"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef339c4486c8dcd6258e2ebc412988ea">GetThreadUtilization</a> (<a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a> type, plUInt32 uiThreadIndex, plUInt32 *pNumTasksExecuted=nullptr)</td></tr>
<tr class="memdesc:aef339c4486c8dcd6258e2ebc412988ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the utilization (0.0 to 1.0) of the given thread. Note: This will only be valid, if <a class="el" href="#ad09288abd3620d337072081234cee5f2" title="Call this function once at the end of a frame. It will ensure that all tasks for &#39;this frame&#39; get fin...">FinishFrameTasks()</a> is called once per frame.  <br /></td></tr>
<tr class="separator:aef339c4486c8dcd6258e2ebc412988ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d824542babc863073122288cbd1128b" id="r_a2d824542babc863073122288cbd1128b"><td class="memItemLeft" align="right" valign="top"><a id="a2d824542babc863073122288cbd1128b" name="a2d824542babc863073122288cbd1128b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>WakeUpThreads</b> (<a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a> type, plUInt32 uiNumThreads)</td></tr>
<tr class="memdesc:a2d824542babc863073122288cbd1128b"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Wakes up or allocates up to <em>uiNumThreads</em>, unless enough threads are currently active and not blocked <br /></td></tr>
<tr class="separator:a2d824542babc863073122288cbd1128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Misc</h2></td></tr>
<tr class="memitem:a0244f9a057fd01a56423aa092d8a3f73" id="r_a0244f9a057fd01a56423aa092d8a3f73"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0244f9a057fd01a56423aa092d8a3f73">SetTargetFrameTime</a> (<a class="el" href="../../d1/df6/structpl_time.htm">plTime</a> targetFrameTime=<a class="el" href="../../d1/df6/structpl_time.htm#a3d1efa40afb39795fad0f3b6401626f1">plTime::MakeFromSeconds</a>(1.0/40.0))</td></tr>
<tr class="memdesc:a0244f9a057fd01a56423aa092d8a3f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target frame time that is supposed to not be exceeded.  <br /></td></tr>
<tr class="separator:a0244f9a057fd01a56423aa092d8a3f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Managing Tasks</h2></td></tr>
<tr class="memitem:ab86b41a3498cf7d3d9533ab7c268c483" id="r_ab86b41a3498cf7d3d9533ab7c268c483"><td class="memItemLeft" align="right" valign="top"><a id="ab86b41a3498cf7d3d9533ab7c268c483" name="ab86b41a3498cf7d3d9533ab7c268c483"></a>
static <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StartSingleTask</b> (const <a class="el" href="../../d6/d8f/classpl_shared_ptr.htm">plSharedPtr</a>&lt; <a class="el" href="../../d9/db9/classpl_task.htm">plTask</a> &gt; &amp;pTask, <a class="el" href="../../d5/d26/structpl_task_priority.htm#abc16c681f03dc7cc9878fa4e8ad781f2">plTaskPriority::Enum</a> priority, <a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a> callback=<a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a>())</td></tr>
<tr class="memdesc:ab86b41a3498cf7d3d9533ab7c268c483"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to insert a single task into the system and start it right away. Returns ID of the Group into which the task has been put. <br /></td></tr>
<tr class="separator:ab86b41a3498cf7d3d9533ab7c268c483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa307795ea273892adeae2b5c04074f0e" id="r_aa307795ea273892adeae2b5c04074f0e"><td class="memItemLeft" align="right" valign="top"><a id="aa307795ea273892adeae2b5c04074f0e" name="aa307795ea273892adeae2b5c04074f0e"></a>
static <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StartSingleTask</b> (const <a class="el" href="../../d6/d8f/classpl_shared_ptr.htm">plSharedPtr</a>&lt; <a class="el" href="../../d9/db9/classpl_task.htm">plTask</a> &gt; &amp;pTask, <a class="el" href="../../d5/d26/structpl_task_priority.htm#abc16c681f03dc7cc9878fa4e8ad781f2">plTaskPriority::Enum</a> priority, <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> dependency, <a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a> callback=<a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a>())</td></tr>
<tr class="memdesc:aa307795ea273892adeae2b5c04074f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to insert a single task into the system and start it right away. Returns ID of the Group into which the task has been put. This overload allows to additionally specify a single dependency. <br /></td></tr>
<tr class="separator:aa307795ea273892adeae2b5c04074f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09288abd3620d337072081234cee5f2" id="r_ad09288abd3620d337072081234cee5f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09288abd3620d337072081234cee5f2">FinishFrameTasks</a> ()</td></tr>
<tr class="memdesc:ad09288abd3620d337072081234cee5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function once at the end of a frame. It will ensure that all tasks for 'this frame' get finished properly.  <br /></td></tr>
<tr class="separator:ad09288abd3620d337072081234cee5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e569b3ea300599bb015019dceefaa1" id="r_a51e569b3ea300599bb015019dceefaa1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/dce/structpl_result.htm">plResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e569b3ea300599bb015019dceefaa1">CancelTask</a> (const <a class="el" href="../../d6/d8f/classpl_shared_ptr.htm">plSharedPtr</a>&lt; <a class="el" href="../../d9/db9/classpl_task.htm">plTask</a> &gt; &amp;pTask, plOnTaskRunning::Enum onTaskRunning=plOnTaskRunning::WaitTillFinished)</td></tr>
<tr class="memdesc:a51e569b3ea300599bb015019dceefaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to remove the given task from the work queue, to prevent it from being executed.  <br /></td></tr>
<tr class="separator:a51e569b3ea300599bb015019dceefaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Managing Task Groups</h2></td></tr>
<tr class="memitem:a0d7d2ee669169edc081ca281eabe48fb" id="r_a0d7d2ee669169edc081ca281eabe48fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7d2ee669169edc081ca281eabe48fb">CreateTaskGroup</a> (<a class="el" href="../../d5/d26/structpl_task_priority.htm#abc16c681f03dc7cc9878fa4e8ad781f2">plTaskPriority::Enum</a> priority, <a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a> callback=<a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a>())</td></tr>
<tr class="memdesc:a0d7d2ee669169edc081ca281eabe48fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new task group for one-time use. Groups need to be recreated every time a task is supposed to be inserted into the system.  <br /></td></tr>
<tr class="separator:a0d7d2ee669169edc081ca281eabe48fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87df869f1b1196aeb471de5ce22452e" id="r_ab87df869f1b1196aeb471de5ce22452e"><td class="memItemLeft" align="right" valign="top"><a id="ab87df869f1b1196aeb471de5ce22452e" name="ab87df869f1b1196aeb471de5ce22452e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>AddTaskToGroup</b> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group, const <a class="el" href="../../d6/d8f/classpl_shared_ptr.htm">plSharedPtr</a>&lt; <a class="el" href="../../d9/db9/classpl_task.htm">plTask</a> &gt; &amp;pTask)</td></tr>
<tr class="memdesc:ab87df869f1b1196aeb471de5ce22452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a task to the given task group. The group must not yet have been started. <br /></td></tr>
<tr class="separator:ab87df869f1b1196aeb471de5ce22452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade22b4fdbefebd24d8dfbf8c3e5c85b" id="r_aade22b4fdbefebd24d8dfbf8c3e5c85b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aade22b4fdbefebd24d8dfbf8c3e5c85b">AddTaskGroupDependency</a> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group, <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> dependsOn)</td></tr>
<tr class="memdesc:aade22b4fdbefebd24d8dfbf8c3e5c85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dependency on another group to <em>Group</em>. This means <em>Group</em> will not be execute before <em>DependsOn</em> has finished.  <br /></td></tr>
<tr class="separator:aade22b4fdbefebd24d8dfbf8c3e5c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1b1745d696f2fac10beb4ccdb93d31" id="r_a5c1b1745d696f2fac10beb4ccdb93d31"><td class="memItemLeft" align="right" valign="top"><a id="a5c1b1745d696f2fac10beb4ccdb93d31" name="a5c1b1745d696f2fac10beb4ccdb93d31"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>AddTaskGroupDependencyBatch</b> (<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; const <a class="el" href="../../dd/db3/structpl_task_group_dependency.htm">plTaskGroupDependency</a> &gt; batch)</td></tr>
<tr class="memdesc:a5c1b1745d696f2fac10beb4ccdb93d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#aade22b4fdbefebd24d8dfbf8c3e5c85b" title="Adds a dependency on another group to Group. This means Group will not be execute before DependsOn ha...">AddTaskGroupDependency()</a> but batches multiple dependency additions. <br /></td></tr>
<tr class="separator:a5c1b1745d696f2fac10beb4ccdb93d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2897aa4ae0b41e6365ab6af209ec778c" id="r_a2897aa4ae0b41e6365ab6af209ec778c"><td class="memItemLeft" align="right" valign="top"><a id="a2897aa4ae0b41e6365ab6af209ec778c" name="a2897aa4ae0b41e6365ab6af209ec778c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>StartTaskGroup</b> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group)</td></tr>
<tr class="memdesc:a2897aa4ae0b41e6365ab6af209ec778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the task group. After this no further modifications on the group (new tasks or dependencies) are allowed. <br /></td></tr>
<tr class="separator:a2897aa4ae0b41e6365ab6af209ec778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47093c23d381876f882b6be7e9d51df2" id="r_a47093c23d381876f882b6be7e9d51df2"><td class="memItemLeft" align="right" valign="top"><a id="a47093c23d381876f882b6be7e9d51df2" name="a47093c23d381876f882b6be7e9d51df2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>StartTaskGroupBatch</b> (<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; const <a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> &gt; batch)</td></tr>
<tr class="memdesc:a47093c23d381876f882b6be7e9d51df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a2897aa4ae0b41e6365ab6af209ec778c" title="Starts the task group. After this no further modifications on the group (new tasks or dependencies) a...">StartTaskGroup()</a> but batches multiple actions. <br /></td></tr>
<tr class="separator:a47093c23d381876f882b6be7e9d51df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813e47148367701af1c14cba566559d" id="r_ad813e47148367701af1c14cba566559d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad813e47148367701af1c14cba566559d">IsTaskGroupFinished</a> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group)</td></tr>
<tr class="memdesc:ad813e47148367701af1c14cba566559d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given <em>Group</em> id refers to a task group that has been finished already.  <br /></td></tr>
<tr class="separator:ad813e47148367701af1c14cba566559d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c2a26a5215cb4b58654f3bfc8505ce" id="r_a56c2a26a5215cb4b58654f3bfc8505ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/dce/structpl_result.htm">plResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56c2a26a5215cb4b58654f3bfc8505ce">CancelGroup</a> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group, plOnTaskRunning::Enum onTaskRunning=plOnTaskRunning::WaitTillFinished)</td></tr>
<tr class="memdesc:a56c2a26a5215cb4b58654f3bfc8505ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels all the tasks in the given group.  <br /></td></tr>
<tr class="separator:a56c2a26a5215cb4b58654f3bfc8505ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ee4e8f8175b2372ddc1b499858cea1" id="r_a23ee4e8f8175b2372ddc1b499858cea1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23ee4e8f8175b2372ddc1b499858cea1">WaitForGroup</a> (<a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> group)</td></tr>
<tr class="memdesc:a23ee4e8f8175b2372ddc1b499858cea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all tasks in the given group have finished.  <br /></td></tr>
<tr class="separator:a23ee4e8f8175b2372ddc1b499858cea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d84b66f1e75c26a26da14c38c00adc3" id="r_a6d84b66f1e75c26a26da14c38c00adc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d84b66f1e75c26a26da14c38c00adc3">WaitForCondition</a> (<a class="el" href="../../df/df1/structpl_delegate.htm">plDelegate</a>&lt; bool()&gt; condition)</td></tr>
<tr class="memdesc:a6d84b66f1e75c26a26da14c38c00adc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the given delegate returns true.  <br /></td></tr>
<tr class="separator:a6d84b66f1e75c26a26da14c38c00adc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Parallel For</h2></td></tr>
<tr class="memitem:abe5af1c58203645519c5a8320ead56f5" id="r_abe5af1c58203645519c5a8320ead56f5"><td class="memItemLeft" align="right" valign="top"><a id="abe5af1c58203645519c5a8320ead56f5" name="abe5af1c58203645519c5a8320ead56f5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ParallelForIndexed</b> (plUInt32 uiStartIndex, plUInt32 uiNumItems, <a class="el" href="../../df/df1/structpl_delegate.htm">plParallelForIndexedFunction32</a> taskCallback, const char *szTaskName=nullptr, plTaskNesting taskNesting=plTaskNesting::Never, const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;params=<a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>())</td></tr>
<tr class="memdesc:abe5af1c58203645519c5a8320ead56f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to process task items in a parallel fashion by having per-worker index ranges generated. <br /></td></tr>
<tr class="separator:abe5af1c58203645519c5a8320ead56f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8d34919dd2bc1cf83990824376ee1e" id="r_aed8d34919dd2bc1cf83990824376ee1e"><td class="memItemLeft" align="right" valign="top"><a id="aed8d34919dd2bc1cf83990824376ee1e" name="aed8d34919dd2bc1cf83990824376ee1e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ParallelForIndexed</b> (plUInt64 uiStartIndex, plUInt64 uiNumItems, <a class="el" href="../../df/df1/structpl_delegate.htm">plParallelForIndexedFunction64</a> taskCallback, const char *szTaskName=nullptr, plTaskNesting taskNesting=plTaskNesting::Never, const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;params=<a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>())</td></tr>
<tr class="memdesc:aed8d34919dd2bc1cf83990824376ee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to process task items in a parallel fashion by having per-worker index ranges generated. <br /></td></tr>
<tr class="separator:aed8d34919dd2bc1cf83990824376ee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63906f0955a740715f8cd409accb8a34" id="r_a63906f0955a740715f8cd409accb8a34"><td class="memTemplParams" colspan="2">template&lt;typename ElemType , typename Callback &gt; </td></tr>
<tr class="memitem:a63906f0955a740715f8cd409accb8a34"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63906f0955a740715f8cd409accb8a34">ParallelFor</a> (<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt; taskItems, Callback taskCallback, const char *szTaskName=nullptr, const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;params=<a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>())</td></tr>
<tr class="separator:a63906f0955a740715f8cd409accb8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e08aba1227e81931c5fc8d6d26e08" id="r_a3b1e08aba1227e81931c5fc8d6d26e08"><td class="memTemplParams" colspan="2">template&lt;typename ElemType , typename Callback &gt; </td></tr>
<tr class="memitem:a3b1e08aba1227e81931c5fc8d6d26e08"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b1e08aba1227e81931c5fc8d6d26e08">ParallelForSingle</a> (<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt; taskItems, Callback taskCallback, const char *szTaskName=nullptr, const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;params=<a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>())</td></tr>
<tr class="separator:a3b1e08aba1227e81931c5fc8d6d26e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d497f64658b383317a2d4c963510d7f" id="r_a1d497f64658b383317a2d4c963510d7f"><td class="memTemplParams" colspan="2">template&lt;typename ElemType , typename Callback &gt; </td></tr>
<tr class="memitem:a1d497f64658b383317a2d4c963510d7f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d497f64658b383317a2d4c963510d7f">ParallelForSingleIndex</a> (<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt; taskItems, Callback taskCallback, const char *szTaskName=nullptr, const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;params=<a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>())</td></tr>
<tr class="separator:a1d497f64658b383317a2d4c963510d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This system allows to automatically distribute tasks onto a number of worker threads. </p>
<p>By deriving from <a class="el" href="../../d9/db9/classpl_task.htm" title="Base class for custom tasks.">plTask</a> you can create your own task types. These can be executed through this task system. You can run a single task using the 'StartSingleTask' function. For more complex setups, it is possible to create groups of tasks, which can have interdependencies. This should be used to group all tasks that belong to one system and need to be done before another system runs. For example you could group all tasks to update particle systems, and then have another group for all tasks to update sound, which depends on the first group, such that sound is only updated after all particle systems are done with.</p>
<p>Although it is possible to wait for tasks or to cancel them, it is generally advised to try to minimize their use. Tasks that might need to be canceled regularly (e.g. path searches) should be implemented in a way that they are aware of being canceled and will stop their work prematurely, instead of running through to the end.</p>
<p>Note that it is crucial to call 'FinishFrameTasks' once per frame, otherwise tasks that need to be executed on the main thread are never executed. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aade22b4fdbefebd24d8dfbf8c3e5c85b" name="aade22b4fdbefebd24d8dfbf8c3e5c85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade22b4fdbefebd24d8dfbf8c3e5c85b">&#9670;&#160;</a></span>AddTaskGroupDependency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::AddTaskGroupDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a></td>          <td class="paramname"><span class="paramname"><em>dependsOn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a dependency on another group to <em>Group</em>. This means <em>Group</em> will not be execute before <em>DependsOn</em> has finished. </p>
<dl class="section note"><dt>Note</dt><dd>Be careful with dependencies and task priorities. A task that has to execute 'this frame' should never depend on a task that needs only finish 'next frame', this might introduce very long and unnecessary waits. A task that has priority 'this frame' or 'next frame' will actually not be executed in 'this frame' or 'next frame' until all its dependencies are fulfilled. So you might add a long running task and a short task which depends on it, but the system will not block at the end of the frame, to wait for the long running task (to finish the short task thereafter), as that short task won't get scheduled for execution, at all, until all its dependencies are actually finished. </dd></dl>

</div>
</div>
<a id="a56c2a26a5215cb4b58654f3bfc8505ce" name="a56c2a26a5215cb4b58654f3bfc8505ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c2a26a5215cb4b58654f3bfc8505ce">&#9670;&#160;</a></span>CancelGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/dce/structpl_result.htm">plResult</a> plTaskSystem::CancelGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plOnTaskRunning::Enum</td>          <td class="paramname"><span class="paramname"><em>onTaskRunning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">plOnTaskRunning::WaitTillFinished</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels all the tasks in the given group. </p>
<p>PL_SUCCESS is returned, if all tasks were already finished or could be removed without waiting for any of them. PL_FAILURE is returned, if at least one task was being processed by another thread and could not be removed without waiting. If bWaitForIt is false, the function cancels all tasks, but returns without blocking, even if not all tasks have been finished. If bWaitForIt is true, the function returns only after it is guaranteed that all tasks are properly terminated. </p>

</div>
</div>
<a id="a51e569b3ea300599bb015019dceefaa1" name="a51e569b3ea300599bb015019dceefaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e569b3ea300599bb015019dceefaa1">&#9670;&#160;</a></span>CancelTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/dce/structpl_result.htm">plResult</a> plTaskSystem::CancelTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d8f/classpl_shared_ptr.htm">plSharedPtr</a>&lt; <a class="el" href="../../d9/db9/classpl_task.htm">plTask</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pTask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plOnTaskRunning::Enum</td>          <td class="paramname"><span class="paramname"><em>onTaskRunning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">plOnTaskRunning::WaitTillFinished</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to remove the given task from the work queue, to prevent it from being executed. </p>
<p>The function will return PL_SUCCESS, if the task could be removed and thus its execution could be prevented. It will also return PL_SUCCESS, if the task was already finished and nothing needed to be done. Tasks that are removed without execution will still be marked as 'finished' and dependent tasks will be scheduled.</p>
<p>PL_FAILURE is returned, if the task had already been started and thus could not be prevented from running.</p>
<p>In case of failure, <em>bWaitForIt</em> determines whether 'WaitForTask' is called (with all its consequences), or whether the function will return immediately.</p>
<p>The cancel flag is set on the task, such that tasks that support canceling might terminate earlier. However, there is no guarantee how long it takes for already running tasks to actually finish. Therefore when bWaitForIt is true, this function might block for a very long time. It is advised to implement tasks that need to be canceled regularly (e.g. path searches for units that might die) in a way that allows for quick canceling. </p>

</div>
</div>
<a id="a0d7d2ee669169edc081ca281eabe48fb" name="a0d7d2ee669169edc081ca281eabe48fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7d2ee669169edc081ca281eabe48fb">&#9670;&#160;</a></span>CreateTaskGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a> plTaskSystem::CreateTaskGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d26/structpl_task_priority.htm#abc16c681f03dc7cc9878fa4e8ad781f2">plTaskPriority::Enum</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../df/df1/structpl_delegate.htm">plOnTaskGroupFinishedCallback</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new task group for one-time use. Groups need to be recreated every time a task is supposed to be inserted into the system. </p>
<p>All tasks that are added to this group will be run with the same given <em>Priority</em>. Once all tasks in the group are finished and thus the group is finished, an optional <em>Callback</em> can be executed. </p>

</div>
</div>
<a id="ad09288abd3620d337072081234cee5f2" name="ad09288abd3620d337072081234cee5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09288abd3620d337072081234cee5f2">&#9670;&#160;</a></span>FinishFrameTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::FinishFrameTasks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function once at the end of a frame. It will ensure that all tasks for 'this frame' get finished properly. </p>
<p>Calling this function is crucial for several reasons. It is the central function to execute 'main thread' tasks. Otherwise these tasks might never get executed. It also changes the priority of all 'next frame' tasks to 'this frame', so that those tasks are guaranteed to get finished when 'FinishFrameTasks' is called the next time.</p>
<p>Finally this function executes tasks with the priority 'SomeFrameMainThread' as long as the target frame time is not exceeded. You can configure this with <a class="el" href="#a0244f9a057fd01a56423aa092d8a3f73" title="Sets the target frame time that is supposed to not be exceeded.">SetTargetFrameTime()</a>, which defines how long (in milliseconds) the frame is allowed to be. As long as that time is not exceeded, additional 'SomeFrameMainThread' tasks will be executed. If the frame time spikes for a few frames, no such tasks will be executed, to prevent making it worse. However, if the frame time stays high over a longer period, 'FinishFrameTasks' will execute 'SomeFrameMainThread' tasks every once in a while, to guarantee some progress.</p>
<dl class="section note"><dt>Note</dt><dd>After this function returns all tasks of priority 'ThisFrameMainThread' are finished. All tasks of priority 'EarlyThisFrame' up to 'LateThisFrame' are either finished or currently running on some thread, so they will be finished soon. There is however no guarantee that they are indeed all finished, as that would introduce unnecessary stalls. </dd></dl>

</div>
</div>
<a id="a40572acab2a634ddb0bb1a7a22c8a7d8" name="a40572acab2a634ddb0bb1a7a22c8a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40572acab2a634ddb0bb1a7a22c8a7d8">&#9670;&#160;</a></span>GetNumAllocatedWorkerThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plUInt32 plTaskSystem::GetNumAllocatedWorkerThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads that have been allocated to potentially work on the given type of task. </p>
<p>CAREFUL! This is not the number of threads that will be active at the same time. Use <a class="el" href="#a5dd2c461748dc990ccb61ddf23c5f3eb" title="Returns the maximum number of threads that should work on the given type of task at the same time.">GetWorkerThreadCount()</a> for that. This is the maximum number of threads that may jump in, if too many threads are blocked. This number will change dynamically at runtime to prevent deadlocks and it can grow very, very large. </p>

</div>
</div>
<a id="aef339c4486c8dcd6258e2ebc412988ea" name="aef339c4486c8dcd6258e2ebc412988ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef339c4486c8dcd6258e2ebc412988ea">&#9670;&#160;</a></span>GetThreadUtilization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double plTaskSystem::GetThreadUtilization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/de8/structpl_worker_thread_type.htm#af5d64169581d49b7c5367f5c97f9501c">plWorkerThreadType::Enum</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32</td>          <td class="paramname"><span class="paramname"><em>uiThreadIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plUInt32 *</td>          <td class="paramname"><span class="paramname"><em>pNumTasksExecuted</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the utilization (0.0 to 1.0) of the given thread. Note: This will only be valid, if <a class="el" href="#ad09288abd3620d337072081234cee5f2" title="Call this function once at the end of a frame. It will ensure that all tasks for &#39;this frame&#39; get fin...">FinishFrameTasks()</a> is called once per frame. </p>
<p>Also optionally returns the number of tasks that were finished during the last frame. </p>

</div>
</div>
<a id="ad813e47148367701af1c14cba566559d" name="ad813e47148367701af1c14cba566559d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813e47148367701af1c14cba566559d">&#9670;&#160;</a></span>IsTaskGroupFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plTaskSystem::IsTaskGroupFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given <em>Group</em> id refers to a task group that has been finished already. </p>
<p>There is no time frame in which group IDs are valid. You may call this function at any time, even 10 minutes later, and it will correctly determine the results. </p>

</div>
</div>
<a id="a63906f0955a740715f8cd409accb8a34" name="a63906f0955a740715f8cd409accb8a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63906f0955a740715f8cd409accb8a34">&#9670;&#160;</a></span>ParallelFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemType , typename Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::ParallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt;</td>          <td class="paramname"><span class="paramname"><em>taskItems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback</td>          <td class="paramname"><span class="paramname"><em>taskCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szTaskName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function to process task items in a parallel fashion by generating per-worker sub-ranges from an initial item array pointer. Given an array pointer 'taskItems' with elements of type ElemType, the following invocations are possible:</p><ul>
<li>ParallelFor(taskItems, [](<a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr&lt;ElemType&gt;</a> taskItemSlice) { }); </li>
</ul>

</div>
</div>
<a id="a3b1e08aba1227e81931c5fc8d6d26e08" name="a3b1e08aba1227e81931c5fc8d6d26e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1e08aba1227e81931c5fc8d6d26e08">&#9670;&#160;</a></span>ParallelForSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemType , typename Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::ParallelForSingle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt;</td>          <td class="paramname"><span class="paramname"><em>taskItems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback</td>          <td class="paramname"><span class="paramname"><em>taskCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szTaskName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function to process task items in a parallel fashion and one-by-one (without global index). Given an array pointer 'taskItems' with elements of type ElemType, the following invocations are possible:</p><ul>
<li>ParallelFor(taskItems, [](ElemType taskItem) { });</li>
<li>ParallelFor(taskItems, [](ElemType&amp; taskItem) { });</li>
<li>ParallelFor(taskItems, [](const ElemType&amp; taskItem) { }); </li>
</ul>

</div>
</div>
<a id="a1d497f64658b383317a2d4c963510d7f" name="a1d497f64658b383317a2d4c963510d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d497f64658b383317a2d4c963510d7f">&#9670;&#160;</a></span>ParallelForSingleIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemType , typename Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::ParallelForSingleIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d81/classpl_array_ptr.htm">plArrayPtr</a>&lt; ElemType &gt;</td>          <td class="paramname"><span class="paramname"><em>taskItems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback</td>          <td class="paramname"><span class="paramname"><em>taskCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szTaskName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d3e/structpl_parallel_for_params.htm">plParallelForParams</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function to process task items in a parallel fashion and one-by-one (with global index). Given an array pointer 'taskItems' with elements of type ElemType, the following invocations are possible:</p><ul>
<li>ParallelFor(taskItems, [](plUInt32 globalTaskItemIndex, ElemType taskItem) { });</li>
<li>ParallelFor(taskItems, [](plUInt32 globalTaskItemIndex, ElemType&amp; taskItem) { });</li>
<li>ParallelFor(taskItems, [](plUInt32 globalTaskItemIndex, const ElemType&amp; taskItem) { }); </li>
</ul>

</div>
</div>
<a id="a0244f9a057fd01a56423aa092d8a3f73" name="a0244f9a057fd01a56423aa092d8a3f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0244f9a057fd01a56423aa092d8a3f73">&#9670;&#160;</a></span>SetTargetFrameTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::SetTargetFrameTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/df6/structpl_time.htm">plTime</a></td>          <td class="paramname"><span class="paramname"><em>targetFrameTime</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d1/df6/structpl_time.htm#a3d1efa40afb39795fad0f3b6401626f1">plTime::MakeFromSeconds</a>(1.0&#160;/&#160;40.0)</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the target frame time that is supposed to not be exceeded. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad09288abd3620d337072081234cee5f2" title="Call this function once at the end of a frame. It will ensure that all tasks for &#39;this frame&#39; get fin...">FinishFrameTasks()</a> for more details. </dd></dl>

</div>
</div>
<a id="a8a9b28000c195e686f3d644ac72f473b" name="a8a9b28000c195e686f3d644ac72f473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b28000c195e686f3d644ac72f473b">&#9670;&#160;</a></span>SetWorkerThreadCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::SetWorkerThreadCount </td>
          <td>(</td>
          <td class="paramtype">plInt32</td>          <td class="paramname"><span class="paramname"><em>iShortTasks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">plInt32</td>          <td class="paramname"><span class="paramname"><em>iLongTasks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of threads to use for the different task categories. </p>
<p><em>uiShortTasks</em> and <em>uiLongTasks</em> must be at least 1 and should not exceed the number of available CPU cores. There will always be exactly one additional thread for file access tasks (<a class="el" href="../../d5/d26/structpl_task_priority.htm#abc16c681f03dc7cc9878fa4e8ad781f2ac586c8f3d143c4c68571bbcd364987b5">plTaskPriority::FileAccess</a>).</p>
<p>If <em>uiShortTasks</em> or <em>uiLongTasks</em> is smaller than 1, a default number of threads will be used for that type of work. This number of threads depends on the number of available CPU cores. If SetWorkThreadCount is never called, at all, the first time any task is started the number of worker threads is set to this default configuration. Unless you have a good idea how to set up the number of worker threads to make good use of the available cores, it is a good idea to just use the default settings. </p>

</div>
</div>
<a id="a6d84b66f1e75c26a26da14c38c00adc3" name="a6d84b66f1e75c26a26da14c38c00adc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d84b66f1e75c26a26da14c38c00adc3">&#9670;&#160;</a></span>WaitForCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::WaitForCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/structpl_delegate.htm">plDelegate</a>&lt; bool()&gt;</td>          <td class="paramname"><span class="paramname"><em>condition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the current thread until the given delegate returns true. </p>
<p>If possible, prefer to use <a class="el" href="#a23ee4e8f8175b2372ddc1b499858cea1" title="Blocks until all tasks in the given group have finished.">WaitForGroup()</a> to wait for some task to finish, as that is the most efficient way. If not possible, prefer to use <a class="el" href="#a6d84b66f1e75c26a26da14c38c00adc3" title="Blocks the current thread until the given delegate returns true.">WaitForCondition()</a> instead of rolling your own busy-loop for polling some state. <a class="el" href="#a6d84b66f1e75c26a26da14c38c00adc3" title="Blocks the current thread until the given delegate returns true.">WaitForCondition()</a> will NOT put the current thread to sleep, but instead keep polling the delegate. However, in between, it will try to execute other tasks and if there are no tasks that it could take on, it will wake up another worker thread thus guaranteeing, that there are enough unblocked threads in the system to do all the work. </p>

</div>
</div>
<a id="a23ee4e8f8175b2372ddc1b499858cea1" name="a23ee4e8f8175b2372ddc1b499858cea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ee4e8f8175b2372ddc1b499858cea1">&#9670;&#160;</a></span>WaitForGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plTaskSystem::WaitForGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d42/classpl_task_group_i_d.htm">plTaskGroupID</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until all tasks in the given group have finished. </p>
<p>If you need to wait for some other task to finish, this should always be the preferred method to do so. WaitForGroup will put the current thread to sleep and use thread signals to only wake it up again once the group is indeed finished. This is the most efficient way to wait for a task. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Engine/Foundation/Threading/<a class="el" href="../../d0/d50/_task_system_8h_source.htm">TaskSystem.h</a></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>ParallelFor.cpp</b></li>
<li>Code/Engine/Foundation/Threading/Implementation/<a class="el" href="../../df/d21/_parallel_for__inl_8h_source.htm">ParallelFor_inl.h</a></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>TaskSystem.cpp</b></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>TaskSystemGroups.cpp</b></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>TaskSystemTasks.cpp</b></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>TaskSystemThreads.cpp</b></li>
<li>Code/Engine/Foundation/Threading/Implementation/<b>TaskSystemUtils.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d5/dc1/classpl_task_system.htm">plTaskSystem</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
